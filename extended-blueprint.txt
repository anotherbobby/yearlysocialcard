ğŸš€ FARCASTER YEARLY SOCIAL TRADING CARD â€” BLUEPRINT v2.0
================================================================================

                    COMPLETE â€¢ OPTIMIZED â€¢ PRODUCTION-READY

================================================================================
                              TABLE OF CONTENTS
================================================================================

 1. Executive Summary
 2. Core Concept & User Journey
 3. Technical Architecture
 4. Smart Contract Specification
 5. Data Structure & Gas Optimization
 6. Rarity System & Calculation
 7. Stats Verification & Security
 8. NFT Metadata & SVG Generation
 9. Royalty System (ERC2981)
10. Minting Rules & Eligibility
11. Leaderboard System
12. Frame Integration (Farcaster)
13. Economic Model & Sustainability
14. Deployment Guide
15. Testing Strategy
16. Edge Cases & Error Handling
17. Roadmap & Future Features


================================================================================
1ï¸âƒ£ EXECUTIVE SUMMARY
================================================================================

PROJECT: Farcaster Yearly Social Trading Card
TAGLINE: Turn your Farcaster activity into a collectible NFT

WHAT IT IS:
An NFT trading card system that captures a user's Farcaster social activity 
over 1 year, with beautiful on-chain SVG art, rarity tiers, and perpetual 
royalties to minters.

KEY FEATURES:
âœ… 1 mint per user per calendar year
âœ… 7 comprehensive stats (casts, likes, replies, recasts, followers, etc.)
âœ… 5 rarity tiers (Common â†’ Legendary)
âœ… Fully on-chain metadata + SVG (no IPFS)
âœ… 3% perpetual royalties to original minter
âœ… Integrated Farcaster Frame for seamless minting
âœ… Gas-optimized for Base L2 (~$0.60 per mint)

TARGET USERS:
- Active Farcaster users wanting social proof
- NFT collectors seeking utility + aesthetics
- Early adopters wanting passive royalty income

TECHNICAL STACK:
- Blockchain: Base L2 (Ethereum)
- Smart Contract: Solidity 0.8.20 (Solady optimized)
- Backend: Node.js + Express
- Stats Provider: Neynar API
- Cache: Redis (leaderboard)
- Frontend: Farcaster Frame (Frog framework)


================================================================================
2ï¸âƒ£ CORE CONCEPT & USER JOURNEY
================================================================================

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         CONCEPT OVERVIEW                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Setiap user Farcaster dapat mint 1 trading card per tahun yang     â”‚
â”‚ merekam aktivitas sosial mereka selama 365 hari terakhir.          â”‚
â”‚                                                                     â”‚
â”‚ Card berisi:                                                        â”‚
â”‚ â€¢ 7 stats komprehensif (casts, likes, engagement, dll)             â”‚
â”‚ â€¢ Rarity tier berdasarkan performa                                 â”‚
â”‚ â€¢ Beautiful SVG art (fully on-chain)                               â”‚
â”‚ â€¢ Tradeable di OpenSea/Blur dengan 3% royalty ke minter            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

USER JOURNEY:

Step 1: Discovery
â”œâ”€ User melihat cast dari teman yang baru mint card
â”œâ”€ Click frame link â†’ masuk ke mini-app
â””â”€ Melihat "Mint Your 2025 Card" CTA

Step 2: Preview Stats
â”œâ”€ Frame fetch stats dari Neynar API
â”œâ”€ Display preview: 7 stats + predicted rarity tier
â””â”€ User melihat "You'll get LEGENDARY tier!"

Step 3: Mint Decision
â”œâ”€ User click "Mint Now (0.0005 ETH)"
â”œâ”€ Wallet popup (MetaMask/Coinbase Wallet)
â”œâ”€ Total cost displayed: ~$2.10 (fee + gas)
â””â”€ User confirm transaction

Step 4: Minting
â”œâ”€ Backend generate signature untuk verify stats
â”œâ”€ Transaction submitted to Base chain
â”œâ”€ Contract verify signature + mint NFT + generate SVG
â””â”€ ~15 seconds later â†’ success!

Step 5: Share & Trade
â”œâ”€ Frame menampilkan beautiful card (SVG rendered)
â”œâ”€ User click "Share to Farcaster" â†’ auto-generate cast
â”œâ”€ Card listed on OpenSea automatically
â””â”€ Future sales â†’ 3% royalty langsung ke minter wallet

ELIGIBILITY RULES:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Rule 1: 1 mint per calendar year per FID                   â”‚
â”‚ Rule 2: Stats window = 365 days rolling dari mint date     â”‚
â”‚ Rule 3: Reset eligibility setiap 1 Januari 00:00 UTC       â”‚
â”‚ Rule 4: Must pay exactly 0.0005 ETH mint fee               â”‚
â”‚ Rule 5: Must have valid signature from trusted backend     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

EXAMPLE SCENARIOS:

Scenario A: Normal Flow
â”œâ”€ User mint: 15 Mei 2025 (first time)
â”œâ”€ Stats period: 15 Mei 2024 â†’ 15 Mei 2025
â”œâ”€ Next eligible: 1 Januari 2026
â””â”€ Try mint 10 Juni 2025 â†’ âŒ REJECTED (same year)

Scenario B: Year Transition
â”œâ”€ User mint: 20 Desember 2025
â”œâ”€ Stats period: 20 Des 2024 â†’ 20 Des 2025
â”œâ”€ Next eligible: 1 Januari 2026 (12 hari kemudian)
â”œâ”€ Mint 5 Januari 2026 â†’ âœ… ALLOWED
â””â”€ New stats period: 5 Jan 2025 â†’ 5 Jan 2026

Scenario C: New User (<1 year on Farcaster)
â”œâ”€ FID created: 1 September 2025
â”œâ”€ Try mint: 15 November 2025
â”œâ”€ Stats period: 1 Sep 2025 â†’ 15 Nov 2025 (partial year)
â””â”€ âœ… ALLOWED (stats akan lebih rendah, likely Common tier)


================================================================================
3ï¸âƒ£ TECHNICAL ARCHITECTURE
================================================================================

SYSTEM DIAGRAM:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         USER (Farcaster App)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  Farcaster Frame â”‚
                    â”‚   (Frontend UI)  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚              â”‚              â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Backend API    â”‚    â”‚    â”‚  Base Blockchain â”‚
    â”‚  (Stats + Sign)  â”‚    â”‚    â”‚  (Smart Contract)â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚             â”‚              â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚              â”‚
    â”‚   Neynar API     â”‚    â”‚              â”‚
    â”‚ (Farcaster Stats)â”‚    â”‚              â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚              â”‚
                            â”‚              â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚      Redis       â”‚    â”‚    â”‚   OpenSea API    â”‚
    â”‚  (Leaderboard)   â”‚    â”‚    â”‚  (NFT Indexer)   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  User's Wallet â”‚
                    â”‚ (MetaMask, CB) â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

COMPONENT BREAKDOWN:

1. FARCASTER FRAME (Frontend)
   â”œâ”€ Technology: Frog framework (Next.js based)
   â”œâ”€ Hosting: Vercel / Railway
   â”œâ”€ Routes:
   â”‚  â”œâ”€ GET /        â†’ Home (mint status + CTA)
   â”‚  â”œâ”€ GET /preview â†’ Stats preview
   â”‚  â”œâ”€ POST /mint   â†’ Trigger mint transaction
   â”‚  â””â”€ GET /success â†’ Post-mint share screen
   â””â”€ Features:
      â”œâ”€ Auto-detect FID from frame context
      â”œâ”€ Wallet connection via Frame Actions
      â””â”€ SVG preview rendering

2. BACKEND API (Stats & Verification)
   â”œâ”€ Technology: Node.js + Express
   â”œâ”€ Hosting: Railway / Render (Docker container)
   â”œâ”€ Endpoints:
   â”‚  â”œâ”€ GET /api/stats/:fid
   â”‚  â”‚  â†’ Fetch stats from Neynar
   â”‚  â”‚  â†’ Calculate rarity tier
   â”‚  â”‚  â†’ Generate ECDSA signature
   â”‚  â”‚  â†’ Return: {stats, signature, canMint}
   â”‚  â”‚
   â”‚  â”œâ”€ POST /api/verify
   â”‚  â”‚  â†’ Verify transaction success
   â”‚  â”‚  â†’ Update leaderboard cache
   â”‚  â”‚
   â”‚  â””â”€ GET /api/leaderboard/:category
   â”‚     â†’ Return top 100 from Redis
   â”‚
   â””â”€ Environment Variables:
      â”œâ”€ NEYNAR_API_KEY
      â”œâ”€ STATS_ORACLE_PRIVATE_KEY (for signing)
      â”œâ”€ CONTRACT_ADDRESS
      â””â”€ REDIS_URL

3. SMART CONTRACT (NFT Logic)
   â”œâ”€ Chain: Base L2 (chainId: 8453)
   â”œâ”€ Language: Solidity 0.8.20
   â”œâ”€ Standards: ERC721 + ERC2981
   â”œâ”€ Optimization: Solady (gas-efficient base)
   â””â”€ Key Features:
      â”œâ”€ Signature verification (ECDSA)
      â”œâ”€ On-chain SVG generation
      â”œâ”€ Packed storage (2 slots per NFT)
      â””â”€ Royalty routing to minter

4. NEYNAR API (Data Source)
   â”œâ”€ Provider: Neynar (Farcaster indexer)
   â”œâ”€ Plan: Growth ($50/mo, 100k req/day)
   â”œâ”€ Endpoints Used:
   â”‚  â”œâ”€ /v2/farcaster/user (profile data)
   â”‚  â”œâ”€ /v2/farcaster/casts (cast count)
   â”‚  â””â”€ /v2/farcaster/reactions (engagement)
   â””â”€ Caching: 1 hour TTL (prevent spam)

5. REDIS (Leaderboard Cache)
   â”œâ”€ Provider: Upstash (serverless Redis)
   â”œâ”€ Plan: Free tier (10k commands/day)
   â”œâ”€ Data Structures:
   â”‚  â”œâ”€ Sorted Sets (leaderboard rankings)
   â”‚  â”œâ”€ Hash Maps (user profile cache)
   â”‚  â””â”€ TTL: 6 hours (auto-refresh)
   â””â”€ Update: Cron job every 6h

DATA FLOW (Detailed):

[1] User clicks "Mint Now" in Frame
      â†“
[2] Frame â†’ Backend API: GET /api/stats/:fid
      â†“
[3] Backend â†’ Neynar API: Fetch 365-day stats
      â†“
[4] Backend calculates rarity score + tier
      â†“
[5] Backend generates signature:
    hash = keccak256(fid, username, stats..., year)
    signature = sign(hash, ORACLE_PRIVATE_KEY)
      â†“
[6] Backend â†’ Frame: Return {stats, signature, rarity}
      â†“
[7] Frame displays preview + "Confirm Mint" button
      â†“
[8] User confirms â†’ Frame calls smart contract mint()
      â†“
[9] Contract verifies signature via ecrecover()
      â†“
[10] If valid â†’ mint NFT + store packed data + emit event
      â†“
[11] Transaction confirmed (~15 sec on Base)
      â†“
[12] Frame â†’ Backend: POST /api/verify (update cache)
      â†“
[13] Frame displays success + share buttons
      â†“
[14] OpenSea auto-indexes NFT within 5 min


================================================================================
4ï¸âƒ£ SMART CONTRACT SPECIFICATION
================================================================================

CONTRACT: FarcasterYearlyCard.sol
VERSION: 1.0.0
LICENSE: MIT

INHERITANCE TREE:
FarcasterYearlyCard
â”œâ”€ ERC721 (from Solady - gas optimized)
â”œâ”€ Ownable (from OpenZeppelin)
â””â”€ IERC2981 (royalty interface)

CONSTANTS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Name             â”‚ Type             â”‚ Value                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ MINT_FEE         â”‚ uint256 constant â”‚ 0.0005 ether           â”‚
â”‚ ROYALTY_BPS      â”‚ uint16 constant  â”‚ 300 (3%)               â”‚
â”‚ MAX_SUPPLY       â”‚ uint256 constant â”‚ type(uint256).max      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

STATE VARIABLES:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Variable          â”‚ Type                      â”‚ Storage Cost         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ _cards            â”‚ mapping(uint256=>CardData)â”‚ 2 slots per token    â”‚
â”‚ _lastMintYear     â”‚ mapping(uint32=>uint256)  â”‚ 1 slot per FID       â”‚
â”‚ _fullUsernames    â”‚ mapping(uint256=>string)  â”‚ Optional (lazy)      â”‚
â”‚ _nextTokenId      â”‚ uint256                   â”‚ 1 slot (shared)      â”‚
â”‚ statsOracle       â”‚ address immutable         â”‚ 0 (in bytecode)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

STRUCT: CardData (Ultra-Optimized - 2 Storage Slots)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         SLOT 1 (256 bits)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ uint32  fid              â”‚ 32 bits  â”‚ Farcaster ID            â”‚
â”‚ uint16  casts            â”‚ 16 bits  â”‚ Total casts (max 65k)   â”‚
â”‚ uint16  likes            â”‚ 16 bits  â”‚ Likes received          â”‚
â”‚ uint16  replies          â”‚ 16 bits  â”‚ Reply count             â”‚
â”‚ uint16  recasts          â”‚ 16 bits  â”‚ Recast count            â”‚
â”‚ uint16  followers        â”‚ 16 bits  â”‚ Followers gained        â”‚
â”‚ uint8   consistency      â”‚ 8 bits   â”‚ Active months (0-12)    â”‚
â”‚ uint8   rarityTier       â”‚ 8 bits   â”‚ Tier (0-4)              â”‚
â”‚ uint16  yearMinted       â”‚ 16 bits  â”‚ Year (2024-2280)        â”‚
â”‚ uint32  mintTimestamp    â”‚ 32 bits  â”‚ Unix timestamp          â”‚
â”‚ uint32  uniqueInteractorsâ”‚ 32 bits  â”‚ Unique users engaged    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                         SLOT 2 (256 bits)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ address minter           â”‚ 160 bits â”‚ Original minter         â”‚
â”‚ bytes12 usernameHash     â”‚ 96 bits  â”‚ Short username ref      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

TOTAL STORAGE: 512 bits = 2 slots = ~40,000 gas per mint
(vs naive approach: 10+ slots = ~200,000 gas)

MAIN FUNCTIONS:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. mint(...)                                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ function mint(                                                      â”‚
â”‚     uint32 fid,                                                     â”‚
â”‚     string calldata username,                                       â”‚
â”‚     uint16 casts,                                                   â”‚
â”‚     uint16 likes,                                                   â”‚
â”‚     uint16 replies,                                                 â”‚
â”‚     uint16 recasts,                                                 â”‚
â”‚     uint16 followers,                                               â”‚
â”‚     uint8 consistency,                                              â”‚
â”‚     uint32 uniqueInteractors,                                       â”‚
â”‚     bytes calldata signature                                        â”‚
â”‚ ) external payable returns (uint256 tokenId)                        â”‚
â”‚                                                                     â”‚
â”‚ Description:                                                        â”‚
â”‚ - Mints a new yearly card NFT                                       â”‚
â”‚ - Verifies signature from trusted backend                           â”‚
â”‚ - Calculates rarity tier on-chain                                   â”‚
â”‚ - Stores packed data (2 slots)                                      â”‚
â”‚ - Emits CardMinted event                                            â”‚
â”‚                                                                     â”‚
â”‚ Checks:                                                             â”‚
â”‚ - require(msg.value == MINT_FEE)                                    â”‚
â”‚ - require(!hasMintedThisYear(fid))                                  â”‚
â”‚ - require(consistency <= 12)                                        â”‚
â”‚ - require(verifySignature(hash, signature))                         â”‚
â”‚                                                                     â”‚
â”‚ Gas: ~150,000                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. tokenURI(uint256 tokenId)                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ function tokenURI(uint256 tokenId)                                  â”‚
â”‚     public view override returns (string memory)                    â”‚
â”‚                                                                     â”‚
â”‚ Description:                                                        â”‚
â”‚ - Generates full metadata JSON on-the-fly                           â”‚
â”‚ - Includes embedded base64 SVG image                                â”‚
â”‚ - No storage cost (computed view function)                          â”‚
â”‚ - Returns data URI format                                           â”‚
â”‚                                                                     â”‚
â”‚ Process:                                                            â”‚
â”‚ 1. Load CardData from storage                                       â”‚
â”‚ 2. Generate SVG via _generateSVG()                                  â”‚
â”‚ 3. Build JSON with attributes                                       â”‚
â”‚ 4. Encode to base64                                                 â”‚
â”‚ 5. Return data:application/json;base64,...                          â”‚
â”‚                                                                     â”‚
â”‚ Gas: ~80,000 (view only, free for users)                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. royaltyInfo(uint256 tokenId, uint256 salePrice)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ function royaltyInfo(uint256 tokenId, uint256 salePrice)            â”‚
â”‚     external view returns (address receiver, uint256 amount)        â”‚
â”‚                                                                     â”‚
â”‚ Description:                                                        â”‚
â”‚ - ERC2981 standard implementation                                   â”‚
â”‚ - Returns original minter address + 3% of sale price                â”‚
â”‚ - Automatically honored by OpenSea, Blur, etc.                      â”‚
â”‚                                                                     â”‚
â”‚ Calculation:                                                        â”‚
â”‚ - receiver = _cards[tokenId].minter                                 â”‚
â”‚ - amount = (salePrice * 300) / 10000                                â”‚
â”‚                                                                     â”‚
â”‚ Gas: ~5,000 (view only)                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. hasMintedThisYear(uint32 fid)                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ function hasMintedThisYear(uint32 fid)                              â”‚
â”‚     public view returns (bool)                                      â”‚
â”‚                                                                     â”‚
â”‚ Description:                                                        â”‚
â”‚ - Checks if FID has minted in current calendar year                 â”‚
â”‚ - Uses simple year comparison                                       â”‚
â”‚                                                                     â”‚
â”‚ Logic:                                                              â”‚
â”‚ uint16 currentYear = uint16(block.timestamp / 365 days + 1970);     â”‚
â”‚ return _lastMintYear[fid] == currentYear;                           â”‚
â”‚                                                                     â”‚
â”‚ Gas: ~2,000 (view only)                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. getCardData(uint256 tokenId)                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ function getCardData(uint256 tokenId)                               â”‚
â”‚     external view returns (CardData memory)                         â”‚
â”‚                                                                     â”‚
â”‚ Description:                                                        â”‚
â”‚ - Returns full unpacked CardData struct                             â”‚
â”‚ - Useful for external apps/analytics                                â”‚
â”‚                                                                     â”‚
â”‚ Gas: ~3,000 (view only)                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

INTERNAL HELPER FUNCTIONS:

1. _calculateRarity(stats...) â†’ uint8
   - Pure function, no storage reads
   - Weighted formula (detailed in section 6)
   - Returns tier 0-4

2. _generateSVG(CardData) â†’ string
   - Generates premium SVG with gradients
   - Dynamic colors based on rarity
   - ~200 lines of SVG code

3. _verifySignature(hash, signature) â†’ bool
   - ECDSA signature verification
   - Uses ecrecover precompile
   - Checks signer == statsOracle

4. _packUsername(string) â†’ bytes12
   - Hash first 12 bytes for storage
   - Fallback to full storage if needed

5. _getRarityColor(tier) â†’ string
   - Returns hex color for tier
   - Gold/Purple/Blue/Green/Gray

EVENTS:

event CardMinted(
    uint256 indexed tokenId,
    uint32 indexed fid,
    address indexed minter,
    uint8 rarityTier,
    uint16 year
);

MODIFIERS:

modifier validFee() {
    require(msg.value == MINT_FEE, "Invalid fee");
    _;
}

modifier notMintedThisYear(uint32 fid) {
    require(!hasMintedThisYear(fid), "Already minted this year");
    _;
}


================================================================================
5ï¸âƒ£ DATA STRUCTURE & GAS OPTIMIZATION
================================================================================

OPTIMIZATION STRATEGY:

Goal: Reduce mint gas from ~450k (naive) to ~150k (optimized)
Method: Multi-layered optimization approach

LAYER 1: STORAGE PACKING (Save ~150k gas)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Technique: Pack multiple values into single uint256 slots      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Before (Naive):                                                 â”‚
â”‚   struct CardData {                                             â”‚
â”‚       uint256 fid;           // 1 slot                          â”‚
â”‚       uint256 casts;         // 1 slot                          â”‚
â”‚       uint256 likes;         // 1 slot                          â”‚
â”‚       ... (10 total fields)  // 10 slots                        â”‚
â”‚   }                                                             â”‚
â”‚   Cost: 10 slots Ã— 20,000 gas = 200,000 gas                    â”‚
â”‚                                                                 â”‚
â”‚ After (Optimized):                                              â”‚
â”‚   struct CardData {                                             â”‚
â”‚       uint32 fid;            // Share slot 1                    â”‚
â”‚       uint16 casts;          // Share slot 1                    â”‚
â”‚       uint16 likes;          // Share slot 1                    â”‚
â”‚       ... (all in 2 slots)   // 2 slots                         â”‚
â”‚   }                                                             â”‚
â”‚   Cost: 2 slots Ã— 20,000 gas = 40,000 gas                      â”‚
â”‚                                                                 â”‚
â”‚ Savings: 160,000 gas (80% reduction)                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

DETAILED PACKING LAYOUT:

Slot 1 (256 bits):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Bit Range â”‚ Type   â”‚ Field              â”‚ Max Value   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0-31      â”‚ uint32 â”‚ fid                â”‚ 4,294,967,295â”‚
â”‚ 32-47     â”‚ uint16 â”‚ casts              â”‚ 65,535      â”‚
â”‚ 48-63     â”‚ uint16 â”‚ likes              â”‚ 65,535      â”‚
â”‚ 64-79     â”‚ uint16 â”‚ replies            â”‚ 65,535      â”‚
â”‚ 80-95     â”‚ uint16 â”‚ recasts            â”‚ 65,535      â”‚
â”‚ 96-111    â”‚ uint16 â”‚ followers          â”‚ 65,535      â”‚
â”‚ 112-119   â”‚ uint8  â”‚ consistency        â”‚ 12          â”‚
â”‚ 120-127   â”‚ uint8  â”‚ rarityTier         â”‚ 4           â”‚
â”‚ 128-143   â”‚ uint16 â”‚ yearMinted         â”‚ 65,535      â”‚
â”‚ 144-175   â”‚ uint32 â”‚ mintTimestamp      â”‚ 4,294,967,295â”‚
â”‚ 176-207   â”‚ uint32 â”‚ uniqueInteractors  â”‚ 4,294,967,295â”‚
â”‚ 208-255   â”‚ -      â”‚ (unused padding)   â”‚ -           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Slot 2 (256 bits):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Bit Range â”‚ Type    â”‚ Field             â”‚ Max Value   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0-159     â”‚ address â”‚ minter            â”‚ -           â”‚
â”‚ 160-255   â”‚ bytes12 â”‚ usernameHash      â”‚ -           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Note: uint16 max (65,535) is sufficient for stats. Users with >65k 
casts/likes are extremely rare (<0.01% of users).

LAYER 2: ON-DEMAND COMPUTATION (Save ~30k gas)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Technique: Generate SVG in view function, not in storage       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Before (Naive):                                                 â”‚
â”‚   - Store full SVG string in contract                           â”‚
â”‚   - Cost: ~3-5 KB Ã— 6k gas/KB = 18-30k gas                     â”‚
â”‚                                                                 â”‚
â”‚ After (Optimized):                                              â”‚
â”‚   - Store only raw data (2 slots)                               â”‚
â”‚   - Generate SVG dynamically in tokenURI()                      â”‚
â”‚   - Cost: 0 gas (view function is free)                        â”‚
â”‚                                                                 â”‚
â”‚ Savings: 30,000 gas                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

LAYER 3: EFFICIENT ELIGIBILITY CHECK (Save ~20k gas)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Technique: Simple year comparison vs array iteration           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Before (Naive):                                                 â”‚
â”‚   mapping(fid => uint256[]) mintedYears;                        â”‚
â”‚   - Iterate array to check eligibility                          â”‚
â”‚   - Cost: ~5k gas per year Ã— avg 3 years = 15-20k gas          â”‚
â”‚                                                                 â”‚
â”‚ After (Optimized):                                              â”‚
â”‚   mapping(fid => uint256) lastMintYear;                         â”‚
â”‚   - Single SLOAD + comparison                                   â”‚
â”‚   - Cost: ~2k gas                                               â”‚
â”‚                                                                 â”‚
â”‚ Savings: 18,000 gas                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

LAYER 4: SOLADY ERC721 (Save ~15k gas)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Technique: Use assembly-optimized ERC721 implementation        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Before: OpenZeppelin ERC721                                     â”‚
â”‚   - Standard Solidity implementation                            â”‚
â”‚   - Mint cost: ~50k gas                                         â”‚
â”‚                                                                 â”‚
â”‚ After: Solady ERC721                                            â”‚
â”‚   - Assembly-optimized hot paths                                â”‚
â”‚   - Mint cost: ~35k gas                                         â”‚
â”‚                                                                 â”‚
â”‚ Savings: 15,000 gas                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

LAYER 5: MINIMAL EVENTS (Save ~5k gas)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Technique: Emit only essential events                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Before (Naive):                                                 â”‚
â”‚   - Multiple custom events for each stat                        â”‚
â”‚   - Cost: ~1.5k gas Ã— 5 events = 7.5k gas                      â”‚
â”‚                                                                 â”‚
â”‚ After (Optimized):                                              â”‚
â”‚   - 1 custom event (CardMinted)                                 â”‚
â”‚   - Rely on standard Transfer event                             â”‚
â”‚   - Cost: ~1.5k gas                                             â”‚
â”‚                                                                 â”‚
â”‚ Savings: 6,000 gas                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

LAYER 6: IMMUTABLE VARIABLES (Save ~2k gas per read)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Technique: Use immutable for constants set in constructor                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Before:                                                         â”‚
â”‚   address public statsOracle; // storage variable              â”‚
â”‚   Cost: 2.1k gas per SLOAD                                      â”‚
â”‚                                                                 â”‚
â”‚ After:                                                          â”‚
â”‚   address public immutable statsOracle; // in bytecode         â”‚
â”‚   Cost: 3 gas per read                                          â”‚
â”‚                                                                 â”‚
â”‚ Savings: ~2k gas per verification (used once per mint)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

TOTAL GAS BREAKDOWN:

Mint Transaction Gas Analysis:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Operation                    â”‚ Gas Cost  â”‚ Optimization       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Base transaction cost        â”‚   21,000  â”‚ Fixed (cannot opt) â”‚
â”‚ Signature verification       â”‚    5,000  â”‚ Precompile (fast)  â”‚
â”‚ Storage (2 slots)            â”‚   40,000  â”‚ Packed data        â”‚
â”‚ Rarity calculation           â”‚    3,000  â”‚ Pure function      â”‚
â”‚ ERC721 mint (Solady)         â”‚   35,000  â”‚ Assembly-opt       â”‚
â”‚ Year tracking update         â”‚    5,000  â”‚ Simple SSTORE      â”‚
â”‚ Event emission               â”‚    1,500  â”‚ Single event       â”‚
â”‚ Function overhead            â”‚   10,000  â”‚ Call stack         â”‚
â”‚ Memory operations            â”‚   12,000  â”‚ Calldata handling  â”‚
â”‚ Refund (gas unused)          â”‚  -15,000  â”‚ Automatic          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ TOTAL                        â”‚  ~150,000 â”‚                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Comparison Table:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Approach           â”‚ Deploy Gas â”‚ Mint Gas â”‚ Total/User      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Naive (unopt)      â”‚   5.0M     â”‚  450k    â”‚ $3.50 (Base)    â”‚
â”‚ Medium opt         â”‚   3.5M     â”‚  250k    â”‚ $2.00           â”‚
â”‚ Full opt (ours)    â”‚   2.5M     â”‚  150k    â”‚ $0.60           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Cost at Current Base Gas Prices (0.01 gwei):
- Deploy: 2.5M gas Ã— 0.01 gwei = 0.025 gwei â‰ˆ $25-35
- Mint: 150k gas Ã— 0.01 gwei = 0.0015 gwei â‰ˆ $0.50-0.80

MEMORY EFFICIENCY:

Contract Size Analysis:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Component              â”‚ Size (bytes) â”‚ % of Total          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ERC721 logic (Solady)  â”‚   ~8,000     â”‚ 42%                 â”‚
â”‚ Mint function          â”‚   ~2,500     â”‚ 13%                 â”‚
â”‚ SVG generation         â”‚   ~4,000     â”‚ 21%                 â”‚
â”‚ Royalty logic          â”‚   ~1,000     â”‚ 5%                  â”‚
â”‚ Helper functions       â”‚   ~2,000     â”‚ 11%                 â”‚
â”‚ Metadata              â”‚   ~1,500     â”‚ 8%                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ TOTAL                  â”‚  ~19,000     â”‚ 100%                â”‚
â”‚ Limit                  â”‚   24,576     â”‚ (79% utilized)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Still ~5.5 KB headroom for future features!

CODE EXAMPLE - PACKING/UNPACKING:
```solidity
// Packing data into Slot 1
function _packSlot1(
    uint32 fid,
    uint16 casts,
    uint16 likes,
    uint16 replies,
    uint16 recasts,
    uint16 followers,
    uint8 consistency,
    uint8 rarityTier,
    uint16 yearMinted,
    uint32 mintTimestamp,
    uint32 uniqueInteractors
) internal pure returns (uint256 packed) {
    packed = uint256(fid) |
             (uint256(casts) << 32) |
             (uint256(likes) << 48) |
             (uint256(replies) << 64) |
             (uint256(recasts) << 80) |
             (uint256(followers) << 96) |
             (uint256(consistency) << 112) |
             (uint256(rarityTier) << 120) |
             (uint256(yearMinted) << 128) |
             (uint256(mintTimestamp) << 144) |
             (uint256(uniqueInteractors) << 176);
}

// Unpacking individual values
function getCasts(uint256 packed) internal pure returns (uint16) {
    return uint16((packed >> 32) & 0xFFFF);
}

function getRarityTier(uint256 packed) internal pure returns (uint8) {
    return uint8((packed >> 120) & 0xFF);
}
```


================================================================================
6ï¸âƒ£ RARITY SYSTEM & CALCULATION
================================================================================

PHILOSOPHY:

Goals:
âœ… Reward consistent engagement over raw numbers
âœ… Make Legendary tier achievable but challenging
âœ… Balance quantity (casts) with quality (interactions)
âœ… Transparent, reproducible calculation

Design Principles:
- NOT just for influencers (10k+ followers)
- Values authentic community engagement
- Consistency weighted heavily (20%)
- Unique interactors = quality metric

FORMULA:

Weighted Scoring System (Max 100 points):

RarityScore = 
  (Casts / 1000) Ã— 10 +              // Max 10 pts â†’ 1000+ casts
  (Likes / 5000) Ã— 20 +               // Max 20 pts â†’ 5000+ likes
  (Replies / 500) Ã— 12 +              // Max 12 pts â†’ 500+ replies
  (Recasts / 500) Ã— 12 +              // Max 12 pts â†’ 500+ recasts
  (Followers / 200) Ã— 8 +             // Max 8 pts â†’ 200+ followers
  (Consistency / 12) Ã— 20 +           // Max 20 pts â†’ 12/12 months
  (UniqueInteractors / 300) Ã— 18      // Max 18 pts â†’ 300+ users

Total: 100 points maximum

TIER MAPPING:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Tier       â”‚ Score Range â”‚ Color   â”‚ Estimated % â”‚ Descriptionâ”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Legendary  â”‚   85-100    â”‚ #FFD700 â”‚    ~5%      â”‚ Elite      â”‚
â”‚ Epic       â”‚   70-84     â”‚ #9B59B6 â”‚   ~10%      â”‚ Very Activeâ”‚
â”‚ Rare       â”‚   50-69     â”‚ #3498DB â”‚   ~20%      â”‚ Active     â”‚
â”‚ Uncommon   â”‚   30-49     â”‚ #2ECC71 â”‚   ~30%      â”‚ Regular    â”‚
â”‚ Common     â”‚    0-29     â”‚ #95A5A6 â”‚   ~35%      â”‚ Casual     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SAMPLE PROFILES:

Profile A: "The Influencer"
â”œâ”€ Casts: 2000 â†’ (2000/1000) Ã— 10 = 20 pts (capped at 10)
â”œâ”€ Likes: 15000 â†’ (15000/5000) Ã— 20 = 60 pts (capped at 20)
â”œâ”€ Replies: 300 â†’ (300/500) Ã— 12 = 7.2 pts
â”œâ”€ Recasts: 800 â†’ (800/500) Ã— 12 = 19.2 pts (capped at 12)
â”œâ”€ Followers: 150 â†’ (150/200) Ã— 8 = 6 pts
â”œâ”€ Consistency: 10/12 â†’ (10/12) Ã— 20 = 16.7 pts
â”œâ”€ Unique: 250 â†’ (250/300) Ã— 18 = 15 pts
â””â”€ TOTAL: 87.9 â†’ LEGENDARY â­

Profile B: "The Consistent Community Builder"
â”œâ”€ Casts: 800 â†’ 8 pts
â”œâ”€ Likes: 3000 â†’ 12 pts
â”œâ”€ Replies: 450 â†’ 10.8 pts
â”œâ”€ Recasts: 350 â†’ 8.4 pts
â”œâ”€ Followers: 180 â†’ 7.2 pts
â”œâ”€ Consistency: 12/12 â†’ 20 pts (full)
â”œâ”€ Unique: 280 â†’ 16.8 pts
â””â”€ TOTAL: 83.2 â†’ EPIC ğŸ’œ

Profile C: "The Casual User"
â”œâ”€ Casts: 250 â†’ 2.5 pts
â”œâ”€ Likes: 800 â†’ 3.2 pts
â”œâ”€ Replies: 80 â†’ 1.9 pts
â”œâ”€ Recasts: 60 â†’ 1.4 pts
â”œâ”€ Followers: 40 â†’ 1.6 pts
â”œâ”€ Consistency: 7/12 â†’ 11.7 pts
â”œâ”€ Unique: 95 â†’ 5.7 pts
â””â”€ TOTAL: 28 â†’ COMMON ğŸ”˜

Profile D: "The New User" (6 months on Farcaster)
â”œâ”€ Casts: 300 â†’ 3 pts
â”œâ”€ Likes: 1200 â†’ 4.8 pts
â”œâ”€ Replies: 120 â†’ 2.9 pts
â”œâ”€ Recasts: 90 â†’ 2.2 pts
â”œâ”€ Followers: 65 â†’ 2.6 pts
â”œâ”€ Consistency: 6/12 â†’ 10 pts (partial year)
â”œâ”€ Unique: 140 â†’ 8.4 pts
â””â”€ TOTAL: 33.9 â†’ UNCOMMON ğŸŸ¢

WEIGHT RATIONALE:

Why Consistency = 20% (highest single metric)?
âœ… Rewards long-term engagement
âœ… Harder to game than raw post count
âœ… Shows genuine community participation
âœ… Encourages sustained activity

Why Unique Interactors = 18%?
âœ… Quality > quantity indicator
âœ… Shows authentic reach
âœ… Hard to fake (requires real engagement)
âœ… Correlates with community value

Why Casts = Only 10%?
âœ… Prevents spam incentive
âœ… Quality matters more than volume
âœ… Balances with engagement metrics
âœ… A few high-quality casts > many low-quality

SOLIDITY IMPLEMENTATION:
```solidity
function _calculateRarity(
    uint16 casts,
    uint16 likes,
    uint16 replies,
    uint16 recasts,
    uint16 followers,
    uint8 consistency,
    uint32 uniqueInteractors
) internal pure returns (uint8 tier) {
    // Calculate weighted score (max 100)
    uint256 score = 
        _min((uint256(casts) * 10) / 1000, 10) +
        _min((uint256(likes) * 20) / 5000, 20) +
        _min((uint256(replies) * 12) / 500, 12) +
        _min((uint256(recasts) * 12) / 500, 12) +
        _min((uint256(followers) * 8) / 200, 8) +
        (uint256(consistency) * 20) / 12 +
        _min((uint256(uniqueInteractors) * 18) / 300, 18);
    
    // Cap at 100
    if (score > 100) score = 100;
    
    // Map to tier
    if (score >= 85) return 4; // Legendary
    if (score >= 70) return 3; // Epic
    if (score >= 50) return 2; // Rare
    if (score >= 30) return 1; // Uncommon
    return 0; // Common
}

function _min(uint256 a, uint256 b) internal pure returns (uint256) {
    return a < b ? a : b;
}
```

TIER DISTRIBUTION (Projected):

Based on typical Farcaster user activity patterns:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Tier       â”‚ Estimated Count (per 10k users)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Legendary  â”‚   ~500 users (5%)  - Top performers               â”‚
â”‚ Epic       â”‚  ~1000 users (10%) - Very active                  â”‚
â”‚ Rare       â”‚  ~2000 users (20%) - Regular posters              â”‚
â”‚ Uncommon   â”‚  ~3000 users (30%) - Casual but consistent        â”‚
â”‚ Common     â”‚  ~3500 users (35%) - Infrequent users             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

This creates healthy scarcity while keeping Legendary achievable!

RARITY METADATA:

On-chain attributes include:
```json
{
  "trait_type": "Rarity Score",
  "value": 87,
  "max_value": 100
},
{
  "trait_type": "Rarity Tier",
  "value": "Legendary"
},
{
  "trait_type": "Rarity Percentile",
  "value": "Top 5%",
  "display_type": "boost_percentage"
}
```

FUTURE ENHANCEMENTS (v2.0):

Potential additions:
- Bonus points for "early adopter" (low FID)
- Seasonal multipliers (e.g., 1.2x during launch month)
- Channel-specific bonuses (e.g., +5 pts for /dev activity)
- Streak bonuses (e.g., consecutive daily casts)


================================================================================
7ï¸âƒ£ STATS VERIFICATION & SECURITY
================================================================================

SECURITY MODEL:

Threat Model:
ğŸ”´ Attack Vector 1: User submits fake stats
ğŸ”´ Attack Vector 2: Replay attack (reuse old signature)
ğŸ”´ Attack Vector 3: Front-running (steal signature)
ğŸ”´ Attack Vector 4: Sybil attack (multiple mints)

Defenses:
âœ… Backend signature verification (trusted oracle)
âœ… Timestamp-bound signatures (10 min expiry)
âœ… On-chain FID â†’ address binding
âœ… Rate limiting on backend

ARCHITECTURE:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TRUSTED ORACLE PATTERN                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Backend (Trusted)                    Smart Contract           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ 1. Fetch stats  â”‚                  â”‚ 4. Verify sig    â”‚    â”‚
â”‚  â”‚    from Neynar  â”‚                  â”‚    via ecrecover â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚           â”‚                                    â”‚               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ 2. Generate     â”‚                  â”‚ 5. If valid,     â”‚    â”‚
â”‚  â”‚    signature    â”‚â”€â”€â”€â”€â”€signatureâ”€â”€â”€â”€â–¶â”‚    mint NFT      â”‚    â”‚
â”‚  â”‚    (ECDSA)      â”‚                  â”‚                  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚           â”‚                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”                                          â”‚
â”‚  â”‚ 3. Return       â”‚                                          â”‚
â”‚  â”‚    {stats, sig} â”‚                                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                          â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SIGNATURE GENERATION (Backend):
```javascript
// backend/services/statsService.js

const ethers = require('ethers');

async function generateStatsSignature(fid, stats) {
  // 1. Get current year
  const year = new Date().getUTCFullYear();
  
  // 2. Create hash of all parameters
  const hash = ethers.solidityPackedKeccak256(
    [
      'uint32',  // fid
      'string',  // username
      'uint16',  // casts
      'uint16',  // likes
      'uint16',  // replies
      'uint16',  // recasts
      'uint16',  // followers
      'uint8',   // consistency
      'uint32',  // uniqueInteractors
      'uint16',  // year
      'uint256'  // timestamp (for expiry)
    ],
    [
      fid,
      stats.username,
      stats.casts,
      stats.likes,
      stats.replies,
      stats.recasts,
      stats.followers,
      stats.consistency,
      stats.uniqueInteractors,
      year,
      Math.floor(Date.now() / 1000) // Unix timestamp
    ]
  );
  
  // 3. Sign with backend private key
  const wallet = new ethers.Wallet(process.env.STATS_ORACLE_PRIVATE_KEY);
  const signature = await wallet.signMessage(ethers.getBytes(hash));
  
  return {
    hash,
    signature,
    expiresAt: Date.now() + (10 * 60 * 1000) // 10 min expiry
  };
}
```

SIGNATURE VERIFICATION (Smart Contract):
```solidity
function _verifySignature(
    bytes32 hash,
    bytes calldata signature
) internal view returns (bool) {
    // 1. Create Ethereum signed message hash
    bytes32 ethSignedHash = keccak256(
        abi.encodePacked("\x19Ethereum Signed Message:\n32", hash)
    );
    
    // 2. Recover signer address
    address signer = _recoverSigner(ethSignedHash, signature);
    
    // 3. Verify signer is trusted oracle
    return signer == statsOracle;
}

function _recoverSigner(
    bytes32 ethSignedHash,
    bytes memory signature
) internal pure returns (address) {
    require(signature.length == 65, "Invalid signature length");
    
    bytes32 r;
    bytes32 s;
    uint8 v;
    
    assembly {
        r := mload(add(signature, 32))
        s := mload(add(signature, 64))
        v := byte(0, mload(add(signature, 96)))
    }
    
    // EIP-2 still allows v=0,1. Adjust if needed
    if (v < 27) v += 27;
    
    return ecrecover(ethSignedHash, v, r, s);
}
```

BACKEND API ENDPOINTS:
```javascript
// GET /api/stats/:fid
app.get('/api/stats/:fid', async (req, res) => {
  const { fid } = req.params;
  
  try {
    // 1. Check rate limit (1 request per FID per hour)
    const cached = await redis.get(`stats:${fid}`);
    if (cached) {
      return res.json(JSON.parse(cached));
    }
    
    // 2. Check if already minted this year
    const hasMinted = await contract.hasMintedThisYear(fid);
    if (hasMinted) {
      return res.status(400).json({
        error: 'Already minted this year',
        nextEligible: `January 1, ${new Date().getUTCFullYear() + 1}`
      });
    }
    
    // 3. Fetch stats from Neynar
    const stats = await fetchNeynarStats(fid);
    
    // 4. Calculate rarity (preview only)
    const rarityScore = calculateRarityScore(stats);
    const rarityTier = getRarityTier(rarityScore);
    
    // 5. Generate signature
    const { signature, expiresAt } = await generateStatsSignature(fid, stats);
    
    // 6. Cache result (1 hour TTL)
    const response = {
      fid,
      stats,
      rarityScore,
      rarityTier,
      signature,
      expiresAt,
      canMint: true
    };
    
    await redis.setex(`stats:${fid}`, 3600, JSON.stringify(response));
    
    res.json(response);
    
  } catch (error) {
    console.error('Stats fetch error:', error);
    res.status(500).json({ error: 'Failed to fetch stats' });
  }
});
```

NEYNAR API INTEGRATION:
```javascript
const { NeynarAPIClient } = require('@neynar/nodejs-sdk');
const neynar = new NeynarAPIClient(process.env.NEYNAR_API_KEY);

async function fetchNeynarStats(fid) {
  // Calculate 365-day window
  const toDate = new Date();
  const fromDate = new Date(toDate);
  fromDate.setDate(fromDate.getDate() - 365);
  
  // Fetch user profile
  const user = await neynar.fetchBulkUsers([fid]);
  const profile = user.users[0];
  
  // Fetch casts in period
  const casts = await neynar.fetchCastsForUser(fid, {
    limit: 1000, // max per request
    cursor: null
  });
  
  // Calculate stats
  const stats = {
    username: profile.username,
    casts: casts.casts.length,
    likes: casts.casts.reduce((sum, cast) => sum + cast.reactions.likes_count, 0),
    replies: casts.casts.filter(c => c.parent_hash).length,
    recasts: casts.casts.reduce((sum, cast) => sum + cast.reactions.recasts_count, 0),
    followers: profile.follower_count,
    consistency: calculateConsistency(casts.casts, fromDate, toDate),
    uniqueInteractors: calculateUniqueInteractors(casts.casts)
  };
  
  return stats;
}

function calculateConsistency(casts, fromDate, toDate) {
  const monthsActive = new Set();
  
  casts.forEach(cast => {
    const date = new Date(cast.timestamp);
    if (date >= fromDate && date <= toDate) {
      monthsActive.add(`${date.getUTCFullYear()}-${date.getUTCMonth()}`);
    }
  });
  
  return monthsActive.size; // 0-12
}

function calculateUniqueInteractors(casts) {
  const interactors = new Set();
  
  casts.forEach(cast => {
    cast.reactions.likes.forEach(like => interactors.add(like.fid));
    cast.replies.forEach(reply => interactors.add(reply.author.fid));
  });
  
  return interactors.size;
}
```

RATE LIMITING:
```javascript
// Redis-based rate limiter
const rateLimit = require('express-rate-limit');
const RedisStore = require('rate-limit-redis');

const limiter = rateLimit({
  store: new RedisStore({
    client: redis,
    prefix: 'rl:'
  }),
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 10, // 10 requests per FID per hour
  keyGenerator: (req) => `fid:${req.params.fid}`,
  message: 'Too many requests, please try again later'
});

app.use('/api/stats/:fid', limiter);
```

SECURITY CHECKLIST:

âœ… Backend private key stored in secure environment variables
âœ… Signature includes timestamp to prevent replay attacks
âœ… Rate limiting prevents API abuse
âœ… Redis caching reduces Neynar API costs
âœ… Contract verifies signature on-chain before minting
âœ… Frontend validates signature expiry before submission
âœ… HTTPS enforced on all API endpoints
âœ… CORS configured to allow only frame domain
âœ… Input validation on all parameters
âœ… Error messages don't leak sensitive info


================================================================================
8ï¸âƒ£ NFT METADATA & SVG GENERATION
================================================================================

METADATA STANDARD: ERC721 + OpenSea Extensions

Full metadata structure:
```json
{
  "name": "Farcaster Card #42 (2025)",
  "description": "1-Year Farcaster activity stats for FID 12345. This card represents authentic social engagement from May 2024 to May 2025.",
  "image": "data:image/svg+xml;base64,PHN2ZyB4bWxu...",
  "external_url": "https://yearly.cards/42",
  "attributes": [
    {
      "trait_type": "FID",
      "value": 12345
    },
    {
      "trait_type": "Year Minted",
      "value": 2025
    },
    {
      "trait_type": "Casts",
      "value": 954,
      "display_type": "number"
    },
    {
      "trait_type": "Likes Received",
      "value": 12044,
      "display_type": "number"
    },
    {
      "trait_type": "Replies",
      "value": 342,
      "display_type": "number"
    },
    {
      "trait_type": "Recasts",
      "value": 587,
      "display_type": "number"
    },
    {
      "trait_type": "Followers Gained",
      "value": 156,
      "display_type": "number"
    },
    {
      "trait_type": "Consistency",
      "value": "11/12"
    },
    {
      "trait_type": "Unique Interactors",
      "value": 287,
      "display_type": "number"
    },
    {
      "trait_type": "Rarity Tier",
      "value": "Legendary"
    },
    {
      "trait_type": "Rarity Score",
      "value": 92,
      "max_value": 100,
      "display_type": "boost_percentage"
    },
    {
      "trait_type": "Engagement Rate",
      "value": 12.6,
      "display_type": "boost_percentage"
    }
  ]
}
```

SVG DESIGN SPECIFICATIONS:

Dimensions: 400Ã—600px (2:3 aspect ratio - card format)
File size: ~4-6 KB (compressed)
Format: SVG 1.1 (maximum compatibility)

Visual Elements:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         SVG LAYOUT                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  [Background Gradient - Rarity Color]                   â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—   â”‚   â”‚
â”‚  â”‚  â•‘                  FARCASTER 2025                  â•‘   â”‚   â”‚
â”‚  â”‚  â•‘              [LEGENDARY CARD]                    â•‘   â”‚
â”‚  â”‚  â• â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•£   â”‚   â”‚
â”‚  â”‚  â•‘                                                  â•‘   â”‚   â”‚
â”‚  â”‚  â•‘               @username                          â•‘   â”‚   â”‚
â”‚  â”‚  â•‘               FID: 12345                         â•‘   â”‚   â”‚
â”‚  â”‚  â•‘                                                  â•‘   â”‚   â”‚
â”‚  â”‚  â• â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•£   â”‚   â”‚
â”‚  â”‚  â•‘  CASTS          LIKES                           â•‘   â”‚   â”‚
â”‚  â”‚  â•‘    954          12,044                          â•‘   â”‚   â”‚
â”‚  â”‚  â•‘                                                  â•‘   â”‚   â”‚
â”‚  â”‚  â•‘  REPLIES        RECASTS                         â•‘   â”‚   â”‚
â”‚  â”‚  â•‘    342            587                           â•‘   â”‚   â”‚
â”‚  â”‚  â•‘                                                  â•‘   â”‚   â”‚
â”‚  â”‚  â•‘  FOLLOWERS      CONSISTENCY                     â•‘   â”‚   â”‚
â”‚  â”‚  â•‘    +156           11/12                         â•‘   â”‚   â”‚
â”‚  â”‚  â•‘                                                  â•‘   â”‚   â”‚
â”‚  â”‚  â•‘  UNIQUE ENGAGEMENTS                             â•‘   â”‚   â”‚
â”‚  â”‚  â•‘       287 users                                 â•‘   â”‚   â”‚
â”‚  â”‚  â• â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•£   â”‚   â”‚
â”‚  â”‚  â•‘  Token #42 â€¢ Minted Nov '25                     â•‘   â”‚   â”‚
â”‚  â”‚  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SOLIDITY SVG GENERATION:
```solidity
function _generateSVG(
    uint256 tokenId,
    CardData memory card
) internal view returns (string memory) {
    string memory rarityColor = _getRarityColor(card.rarityTier);
    string memory rarityName = _getRarityName(card.rarityTier);
    string memory username = _getUsername(tokenId, card);
    
    return string(abi.encodePacked(
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 600">',
        _generateDefs(rarityColor),
        _generateBackground(),
        _generateHeader(card.yearMinted, rarityName, rarityColor),
        _generateUserInfo(username, card.fid),
        _generateStatsGrid(card),
        _generateFooter(tokenId, card.mintTimestamp),
        '</svg>'
    ));
}

function _generateDefs(string memory rarityColor) internal pure returns (string memory) {
    return string(abi.encodePacked(
        '<defs>',
          '<linearGradient id="bg" x1="0%" y1="0%" x2="100%" y2="100%">',
            '<stop offset="0%" style="stop-color:', rarityColor, ';stop-opacity:1"/>',
            '<stop offset="100%" style="stop-color:#000;stop-opacity:0.85"/>',
          '</linearGradient>',
          '<filter id="glow">',
            '<feGaussianBlur stdDeviation="4" result="coloredBlur"/>',
            '<feMerge>',
              '<feMergeNode in="coloredBlur"/>',
              '<feMergeNode in="SourceGraphic"/>',
            '</feMerge>',
          '</filter>',
          '<filter id="shadow">',
            '<feDropShadow dx="0" dy="2" stdDeviation="3" flood-opacity="0.3"/>',
          '</filter>',
        '</defs>'
    ));
}

function _generateBackground() internal pure returns (string memory) {
    return string(abi.encodePacked(
        '<rect width="400" height="600" fill="url(#bg)"/>',
        '<rect x="20" y="20" width="360" height="560" fill="rgba(0,0,0,0.5)" ',
        'rx="15" filter="url(#shadow)"/>',
        '<rect x="25" y="25" width="350" height="550" fill="none" ',
        'stroke="rgba(255,255,255,0.1)" stroke-width="1" rx="12"/>'
    ));
}

function _generateHeader(
    uint16 year,
    string memory rarityName,
    string memory rarityColor
) internal pure returns (string memory) {
    return string(abi.encodePacked(
        '<text x="200" y="70" text-anchor="middle" fill="#fff" ',
        'font-size="32" font-weight="bold" font-family="Arial, sans-serif" ',
        'filter="url(#glow)">',
        'FARCASTER ', Strings.toString(year),
        '</text>',
        '<rect x="120" y="85" width="160" height="28" fill="', rarityColor, '" ',
        'rx="14" opacity="0.3"/>',
        '<text x="200" y="105" text-anchor="middle" fill="', rarityColor, '" ',
        'font-size="16" font-weight="bold" font-family="Arial, sans-serif">',
        rarityName, ' CARD',
        '</text>'
    ));
}

function _generateUserInfo(
    string memory username,
    uint32 fid
) internal pure returns (string memory) {
    return string(abi.encodePacked(
        '<text x="200" y="160" text-anchor="middle" fill="#fff" ',
        'font-size="24" font-weight="bold" font-family="Arial, sans-serif">',
        '@', username,
        '</text>',
        '<text x="200" y="185" text-anchor="middle" fill="#aaa" ',
        'font-size="14" font-family="Arial, sans-serif">',
        'FID: ', Strings.toString(fid),
        '</text>'
    ));
}

function _generateStatsGrid(CardData memory card) internal pure returns (string memory) {
    return string(abi.encodePacked(
        // Row 1
        _generateStatBox(60, 230, "CASTS", Strings.toString(card.casts)),
        _generateStatBox(220, 230, "LIKES", _formatNumber(card.likes)),
        
        // Row 2
        _generateStatBox(60, 320, "REPLIES", Strings.toString(card.replies)),
        _generateStatBox(220, 320, "RECASTS", Strings.toString(card.recasts)),
        
        // Row 3
        _generateStatBox(60, 410, "FOLLOWERS", string(abi.encodePacked("+", Strings.toString(card.followers)))),
        _generateStatBox(220, 410, "CONSISTENCY", string(abi.encodePacked(Strings.toString(card.consistency), "/12"))),
        
        // Full width stat
        '<rect x="50" y="480" width="300" height="60" fill="rgba(255,255,255,0.05)" rx="8"/>',
        '<text x="200" y="505" text-anchor="middle" fill="#999" font-size="11" ',
        'font-family="Arial, sans-serif">UNIQUE ENGAGEMENTS</text>',
        '<text x="200" y="530" text-anchor="middle" fill="#fff" font-size="22" ',
        'font-weight="bold" font-family="Arial, sans-serif">',
        Strings.toString(card.uniqueInteractors), ' users',
        '</text>'
    ));
}

function _generateStatBox(
    uint256 x,
    uint256 y,
    string memory label,
    string memory value
) internal pure returns (string memory) {
    return string(abi.encodePacked(
        '<g transform="translate(', Strings.toString(x), ',', Strings.toString(y), ')">',
          '<rect width="130" height="70" fill="rgba(255,255,255,0.05)" rx="8"/>',
          '<text x="65" y="25" text-anchor="middle" fill="#999" font-size="11" ',
          'font-family="Arial, sans-serif">', label, '</text>',
          '<text x="65" y="55" text-anchor="middle" fill="#fff" font-size="24" ',
          'font-weight="bold" font-family="Arial, sans-serif">', value, '</text>',
        '</g>'
    ));
}

function _generateFooter(
    uint256 tokenId,
    uint32 mintTimestamp
) internal pure returns (string memory) {
    return string(abi.encodePacked(
        '<line x1="40" y1="565" x2="360" y2="565" stroke="rgba(255,255,255,0.1)" stroke-width="1"/>',
        '<text x="200" y="585" text-anchor="middle" fill="#666" font-size="11" ',
        'font-family="Arial, sans-serif">',
        'Token #', Strings.toString(tokenId), ' â€¢ Minted ', _formatDate(mintTimestamp),
        '</text>'
    ));
}

function _formatNumber(uint16 num) internal pure returns (string memory) {
    if (num < 1000) return Strings.toString(num);
    
    // Format with comma (e.g., 12,044)
    uint256 thousands = num / 1000;
    uint256 remainder = num % 1000;
    
    string memory remainderStr = Strings.toString(remainder);
    
    // Pad with zeros if needed
    if (remainder < 10) remainderStr = string(abi.encodePacked("00", remainderStr));
    else if (remainder < 100) remainderStr = string(abi.encodePacked("0", remainderStr));
    
    return string(abi.encodePacked(
        Strings.toString(thousands),
        ",",
        remainderStr
    ));
}

function _formatDate(uint32 timestamp) internal pure returns (string memory) {
    uint256 year = 1970 + (timestamp / 365 days);
    uint256 month = ((timestamp % 365 days) / 30 days) + 1;
    
    string[12] memory months = [
        "Jan", "Feb", "Mar", "Apr", "May", "Jun",
        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
    ];
    
    return string(abi.encodePacked(
        months[month - 1],
        " '",
        Strings.toString(year % 100)
    ));
}

function _getRarityColor(uint8 tier) internal pure returns (string memory) {
    if (tier == 4) return "#FFD700"; // Legendary - Gold
    if (tier == 3) return "#9B59B6"; // Epic - Purple
    if (tier == 2) return "#3498DB"; // Rare - Blue
    if (tier == 1) return "#2ECC71"; // Uncommon - Green
    return "#95A5A6"; // Common - Gray
}

function _getRarityName(uint8 tier) internal pure returns (string memory) {
    if (tier == 4) return "LEGENDARY";
    if (tier == 3) return "EPIC";
    if (tier == 2) return "RARE";
    if (tier == 1) return "UNCOMMON";
    return "COMMON";
}

function _getUsername(uint256 tokenId, CardData memory card) internal view returns (string memory) {
    // Try to get full username from optional storage
    string memory full = _fullUsernames[tokenId];
    if (bytes(full).length > 0) return full;
    
    // Fallback: reconstruct from FID
    return string(abi.encodePacked("user", Strings.toString(card.fid)));
}


SVG OUTPUT EXAMPLE (LEGENDARY) :

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 600">
  <defs>
    <linearGradient id="bg" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#FFD700;stop-opacity:1"/>
      <stop offset="100%" style="stop-color:#000;stop-opacity:0.85"/>
    </linearGradient>
    <filter id="glow">
      <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
      <feMerge>
        <feMergeNode in="coloredBlur"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  </defs>
  
  <!-- Background -->
  <rect width="400" height="600" fill="url(#bg)"/>
  <rect x="20" y="20" width="360" height="560" fill="rgba(0,0,0,0.5)" rx="15"/>
  
  <!-- Header -->
  <text x="200" y="70" text-anchor="middle" fill="#fff" font-size="32" 
        font-weight="bold" filter="url(#glow)">FARCASTER 2025</text>
  <text x="200" y="105" text-anchor="middle" fill="#FFD700" font-size="16" 
        font-weight="bold">LEGENDARY CARD</text>
  
  <!-- User Info -->
  <text x="200" y="160" text-anchor="middle" fill="#fff" font-size="24" 
        font-weight="bold">@alice</text>
  <text x="200" y="185" text-anchor="middle" fill="#aaa" font-size="14">FID: 12345</text>
  
  <!-- Stats Grid -->
  <!-- ... (all stat boxes) ... -->
  
  <!-- Footer -->
  <text x="200" y="585" text-anchor="middle" fill="#666" font-size="11">
    Token #42 â€¢ Minted Nov '25
  </text>
</svg>

FILE SIZE ANALYSIS:
Typical SVG sizes by tier:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Tier       â”‚ SVG Size â”‚ Base64 Size â”‚ Gas Impact          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Common     â”‚  ~3.5 KB â”‚   ~4.7 KB   â”‚ Minimal (view only) â”‚
â”‚ Uncommon   â”‚  ~3.8 KB â”‚   ~5.1 KB   â”‚ Minimal             â”‚
â”‚ Rare       â”‚  ~4.0 KB â”‚   ~5.3 KB   â”‚ Minimal             â”‚
â”‚ Epic       â”‚  ~4.2 KB â”‚   ~5.6 KB   â”‚ Minimal             â”‚
â”‚ Legendary  â”‚  ~4.5 KB â”‚   ~6.0 KB   â”‚ Minimal             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Note: SVG generated on-the-fly in view function = 0 storage gas!
OPENSEA RENDERING:
OpenSea will:

Call tokenURI(tokenId)
Decode base64 data URI
Parse JSON metadata
Extract image (base64 SVG)
Render in browser/app
Cache for 24 hours

Refresh metadata: OpenSea refresh button triggers new tokenURI() call
================================================================================
9ï¸âƒ£ ROYALTY SYSTEM (ERC2981)
STANDARD: ERC-2981 NFT Royalty Standard
Interface:
interface IERC2981 {
    function royaltyInfo(
        uint256 tokenId,
        uint256 salePrice
    ) external view returns (
        address receiver,
        uint256 royaltyAmount
    );
}

IMPLEMENTATION:
contract FarcasterYearlyCard is ERC721, IERC2981 {
    uint16 public constant ROYALTY_BPS = 300; // 3% = 300 basis points
    
    /**
     * @notice Returns royalty info for a token sale
     * @dev ERC2981 standard - supported by all major marketplaces
     * @param tokenId The NFT token ID
     * @param salePrice The sale price of the NFT
     * @return receiver The address to receive royalty (original minter)
     * @return royaltyAmount The royalty amount (3% of sale price)
     */
    function royaltyInfo(
        uint256 tokenId,
        uint256 salePrice
    ) external view override returns (
        address receiver,
        uint256 royaltyAmount
    ) {
        require(_exists(tokenId), "Token does not exist");
        
        // Royalty goes to original minter (NOT current owner)
        CardData memory card = _cards[tokenId];
        receiver = card.minter;
        
        // Calculate 3% of sale price
        royaltyAmount = (salePrice * ROYALTY_BPS) / 10000;
        
        return (receiver, royaltyAmount);
    }
    
    /**
     * @notice Check interface support
     * @dev Includes ERC2981 interface ID
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override
        returns (bool)
    {
        return
            interfaceId == 0x2a55205a || // ERC2981
            super.supportsInterface(interfaceId);
    }
}

ROYALTY FLOW:
EXAMPLE SCENARIOS:
Scenario 1: Card sells for 0.01 ETH ($30)
â”œâ”€ Royalty: 0.0003 ETH ($0.90) â†’ original minter
â”œâ”€ OpenSea fee: 0.00025 ETH ($0.75) â†’ marketplace
â””â”€ Seller receives: 0.00945 ETH ($28.35)
Scenario 2: Card sells for 0.1 ETH ($300)
â”œâ”€ Royalty: 0.003 ETH ($9.00) â†’ original minter
â”œâ”€ OpenSea fee: 0.0025 ETH ($7.50) â†’ marketplace
â””â”€ Seller receives: 0.0945 ETH ($283.50)
Scenario 3: Card sells for 1 ETH ($3000) - rare!
â”œâ”€ Royalty: 0.03 ETH ($90) â†’ original minter
â”œâ”€ OpenSea fee: 0.025 ETH ($75) â†’ marketplace
â””â”€ Seller receives: 0.945 ETH ($2835)
MINTER LIFETIME VALUE ANALYSIS:
Assumptions:

Card minted in 2025
Trades 10 times over 5 years
Average sale price increases 20% per year
Starting price: 0.01 ETH ($30)

Year-by-year projection:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Year â”‚ Avg Price â”‚ Sales â”‚ Royalty/Sale â”‚ Total Royalty      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2025 â”‚  $30      â”‚   2   â”‚    $0.90     â”‚    $1.80           â”‚
â”‚ 2026 â”‚  $36      â”‚   2   â”‚    $1.08     â”‚    $2.16           â”‚
â”‚ 2027 â”‚  $43      â”‚   2   â”‚    $1.29     â”‚    $2.58           â”‚
â”‚ 2028 â”‚  $52      â”‚   2   â”‚    $1.56     â”‚    $3.12           â”‚
â”‚ 2029 â”‚  $62      â”‚   2   â”‚    $1.86     â”‚    $3.72           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ TOTALâ”‚           â”‚  10   â”‚              â”‚   $13.38           â”‚
â”‚                                                                 â”‚
â”‚ Initial mint cost: $2.10                                        â”‚
â”‚ Net profit: $11.28                                              â”‚
â”‚ ROI: 537%                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Best case (Legendary card, high demand):

50 sales over 5 years
Average price: $100
Total royalty: $150
ROI: 7,000%+

MARKETPLACE SUPPORT:
Platforms that honor ERC2981:
âœ… OpenSea (Base chain supported)
âœ… Blur (partial support)
âœ… LooksRare
âœ… Rarible
âœ… Foundation
âœ… X2Y2
Note: Some marketplaces allow buyers to opt-out of royalties, but
OpenSea on Base typically enforces creator royalties.
CONTRACT METADATA (for OpenSea):
function contractURI() public pure returns (string memory) {
    return string(abi.encodePacked(
        'data:application/json;utf8,',
        '{"name":"Farcaster Yearly Card",',
        '"description":"Annual social trading cards for Farcaster users",',
        '"image":"https://yearly.cards/og-image.png",',
        '"external_link":"https://yearly.cards",',
        '"seller_fee_basis_points":300,', // 3% royalty
        '"fee_recipient":"', // Dynamically set per token
        '}'
    ));
}

WHY ROYALTIES TO MINTER (not current owner)?
Benefits:
âœ… Rewards early adopters
âœ… Creates passive income stream
âœ… Incentivizes minting (not just flipping)
âœ… Aligns long-term value with community
âœ… Unique selling point vs competitors
âœ… Fair: minter "created" the data value
Alternative considered (rejected):
âŒ Royalty to protocol â†’ less user incentive
âŒ Royalty to current owner â†’ no early adopter benefit
âŒ No royalty â†’ missed passive income opportunity
================================================================================
ğŸ”Ÿ MINTING RULES & ELIGIBILITY
CORE RULES:
Rule 1: ONE MINT PER CALENDAR YEAR
â”œâ”€ Each FID can mint maximum 1 card per calendar year
â”œâ”€ Year = UTC year (2025, 2026, etc.)
â”œâ”€ Enforced by: mapping(uint32 fid => uint256 lastMintYear)
â””â”€ Check: require(_lastMintYear[fid] != currentYear)
Rule 2: ROLLING STATS WINDOW
â”œâ”€ Stats calculated from: mintDate - 365 days â†’ mintDate
â”œâ”€ NOT calendar year (Jan-Dec)
â”œâ”€ Example: Mint May 15, 2025 â†’ stats from May 15, 2024
â””â”€ Allows fair comparison regardless of mint date
Rule 3: ELIGIBILITY RESET
â”œâ”€ Reset happens: Every January 1st 00:00 UTC
â”œâ”€ After reset: User can mint again (even if minted Dec 31)
â”œâ”€ New stats window: From new mint date - 365 days
â””â”€ Example: Mint Dec 20, 2025 â†’ eligible again Jan 1, 2026
Rule 4: EXACT MINT FEE
â”œâ”€ Must pay exactly 0.0005 ETH
â”œâ”€ No overpayment accepted (prevents accidents)
â”œâ”€ Gas fee paid separately to network
â””â”€ Fee sent to contract (owner can withdraw)
Rule 5: VALID SIGNATURE REQUIRED
â”œâ”€ Stats must be signed by trusted backend (statsOracle)
â”œâ”€ Signature includes timestamp (10 min expiry)
â”œâ”€ Prevents fake stats submission
â””â”€ Signature verified on-chain via ecrecover()
ELIGIBILITY CHECK LOGIC:
function hasMintedThisYear(uint32 fid) public view returns (bool) {
    // Calculate current UTC year
    uint16 currentYear = uint16(block.timestamp / 365 days + 1970);
    
    // Check if last mint was this year
    return _lastMintYear[fid] == currentYear;
}

function canMint(uint32 fid) external view returns (
    bool eligible,
    string memory reason,
    uint256 nextEligibleTimestamp
) {
    if (hasMintedThisYear(fid)) {
        // Calculate next January 1st
        uint16 currentYear = uint16(block.timestamp / 365 days + 1970);
        uint256 nextYear = currentYear + 1;
        uint256 nextJan1 = (nextYear - 1970) * 365 days;
        
        return (
            false,
            "Already minted this year",
            nextJan1
        );
    }
    
    return (true, "Eligible to mint", 0);
}

MINT FUNCTION FLOW:
function mint(
    uint32 fid,
    string calldata username,
    uint16 casts,
    uint16 likes,
    uint16 replies,
    uint16 recasts,
    uint16 followers,
    uint8 consistency,
    uint32 uniqueInteractors,
    bytes calldata signature
) external payable returns (uint256 tokenId) {
    // ===== VALIDATION CHECKS =====
    
    // Check 1: Exact fee
    require(msg.value == MINT_FEE, "Invalid mint fee");
    
    // Check 2: Not minted this year
    require(!hasMintedThisYear(fid), "Already minted this year");
    
    // Check 3: Valid consistency value
    require(consistency <= 12, "Invalid consistency value");
    
    // Check 4: Valid signature
    uint16 year = uint16(block.timestamp / 365 days + 1970);
    bytes32 hash = keccak256(abi.encodePacked(
        fid, username, casts, likes, replies, recasts,
        followers, consistency, uniqueInteractors, year
    ));
    require(_verifySignature(hash, signature), "Invalid signature");
    
    // ===== MINT LOGIC =====
    
    // Calculate rarity tier
    uint8 rarityTier = _calculateRarity(
        casts, likes, replies, recasts, followers,
        consistency, uniqueInteractors
    );
    
    // Get next token ID
    tokenId = _nextTokenId++;
    
    // Store packed card data (2 storage slots)
    _cards[tokenId] = CardData({
        fid: fid,
        casts: casts,
        likes: likes,
        replies: replies,
        recasts: recasts,
        followers: followers,
        consistency: consistency,
        rarityTier: rarityTier,
        yearMinted: year,
        mintTimestamp: uint32(block.timestamp),
        uniqueInteractors: uniqueInteractors,
        minter: msg.sender,
        usernameHash: bytes12(keccak256(bytes(username)))
    });
    
    // Store full username if > 12 chars (optional)
    if (bytes(username).length > 12) {
        _fullUsernames[tokenId] = username;
    }
    
    // Mark year as minted
    _lastMintYear[fid] = year;
    
    // Mint NFT to sender
    _mint(msg.sender, tokenId);
    
    // Emit event
    emit CardMinted(tokenId, fid, msg.sender, rarityTier, year);
    
    return tokenId;
}

EDGE CASES HANDLED:
Case 1: New User (<365 days on Farcaster)
â”œâ”€ Stats will be based on available data
â”œâ”€ Consistency will be proportionally lower
â”œâ”€ Likely result: Common or Uncommon tier
â””â”€ Still eligible to mint
Case 2: Inactive User (0 casts in period)
â”œâ”€ All stats will be 0 or very low
â”œâ”€ Rarity score: ~0
â”œâ”€ Result: Common tier
â””â”€ Still eligible to mint (pays $2.10 for proof of account)
Case 3: Username Change
â”œâ”€ Username stored at mint time
â”œâ”€ If user changes username later, card shows old username
â”œâ”€ FID never changes (immutable identifier)
â””â”€ Adds "historical snapshot" value
Case 4: Account Deletion
â”œâ”€ FID remains valid on-chain
â”œâ”€ Card still tradeable (historical artifact)
â”œâ”€ Increases rarity (account no longer exists)
â””â”€ NFT independent of Farcaster account status
Case 5: Multiple Wallets, Same FID
â”œâ”€ Eligibility tied to FID, not wallet address
â”œâ”€ User can mint from any wallet they control
â”œâ”€ But still only 1 mint per FID per year
â””â”€ Royalties always go to original minting wallet
Case 6: Year Boundary Mint
â”œâ”€ Mint Dec 31, 2025 at 23:59 UTC â†’ allowed
â”œâ”€ Mint Jan 1, 2026 at 00:01 UTC â†’ allowed (new year)
â”œâ”€ Both mints valid, different token IDs
â””â”€ Shortest possible window: ~2 minutes apart
FRONTEND VALIDATION (Before Transaction):
// frame/utils/mintValidation.js

async function validateMintEligibility(fid) {
  // Check 1: Already minted this year?
  const hasMinted = await contract.hasMintedThisYear(fid);
  if (hasMinted) {
    const nextYear = new Date().getUTCFullYear() + 1;
    return {
      canMint: false,
      reason: `Already minted in ${new Date().getUTCFullYear()}`,
      nextEligible: `January 1, ${nextYear}`
    };
  }
  
  // Check 2: Valid stats available?
  try {
    const stats = await fetch(`/api/stats/${fid}`);
    if (!stats.ok) {
      return {
        canMint: false,
        reason: "Unable to fetch stats from Neynar",
        nextEligible: null
      };
    }
  } catch (error) {
    return {
      canMint: false,
      reason: "API error - please try again",
      nextEligible: null
    };
  }
  
  // Check 3: Wallet has sufficient balance?
  const balance = await provider.getBalance(userAddress);
  const required = ethers.parseEther("0.001"); // 0.0005 + gas buffer
  if (balance < required) {
    return {
      canMint: false,
      reason: "Insufficient ETH balance (need ~0.001 ETH)",
      nextEligible: null
    };
  }
  
  return {
    canMint: true,
    reason: "Eligible to mint!",
    nextEligible: null
  };
}
```

ANTI-GAMING MEASURES:

Prevention 1: No "Stats Farming"
â”œâ”€ Rolling window prevents gaming specific timeframes
â”œâ”€ Can't wait for "good month" then mint
â””â”€ Stats always represent full 365 days

Prevention 2: No "Sybil Attacks"
â”œâ”€ Each FID can only mint once per year
â”œâ”€ Creating multiple FIDs doesn't help (each needs real activity)
â””â”€ Cost of gaming > value gained

Prevention 3: No "Signature Replay"
â”œâ”€ Signature includes current year
â”œâ”€ Old signatures invalid in new year
â””â”€ Frontend checks signature expiry (10 min)

Prevention 4: No "Front-Running"
â”œâ”€ Signature tied to specific FID
â”œâ”€ Can't steal someone else's signature
â””â”€ ecrecover verifies authentic signer


================================================================================
1ï¸âƒ£1ï¸âƒ£ LEADERBOARD SYSTEM
================================================================================

PURPOSE:
- Showcase top performers
- Create competitive element
- Drive engagement & sharing
- Highlight rare cards

CATEGORIES (7 Total):

1. ğŸ† Most Casts (12-month window)
2. â¤ï¸ Most Likes Received
3. ğŸ’¬ Highest Engagement Rate
4. ğŸ“… Perfect Consistency (12/12)
5. â­ Highest Rarity Score
6. ğŸ’° Top Traders (most royalty earned)
7. ğŸ’ Most Valuable Card (highest sale price)

TECH STACK:

Data Store: Redis (Upstash serverless)
Update Frequency: Every 6 hours (cron job)
Display: Top 100 per category
Caching: 1 hour TTL on API responses

REDIS SCHEMA:
```
Key Pattern: leaderboard:{category}:{year}
Type: Sorted Set (ZADD)

Examples:
- leaderboard:casts:2025
- leaderboard:likes:2025
- leaderboard:engagement:2025
- leaderboard:rarity:2025
- leaderboard:royalty:2025
- leaderboard:value:2025

REDIS OPERATION:
// Add/update entry
await redis.zadd(
  'leaderboard:casts:2025',
  954,      // score (casts count)
  'fid:12345' // member (unique identifier)
);

// Get top 100
const top100 = await redis.zrevrange(
  'leaderboard:casts:2025',
  0,
  99,
  'WITHSCORES'
);

// Get user's rank
const rank = await redis.zrevrank(
  'leaderboard:casts:2025',
  'fid:12345'
);

// Get user's score
const score = await redis.zscore(
  'leaderboard:casts:2025',
  'fid:12345'
);

BACKEND CRON JOB
// backend/jobs/updateLeaderboard.js
```javascript
const cron = require('node-cron');
const redis = require('../services/redis');
const { contract } = require('../services/contract');

// Run every 6 hours
cron.schedule('0 */6 * * *', async () => {
  console.log('Starting leaderboard update...');
  
  try {
    const currentYear = new Date().getUTCFullYear();
    
    // Get all minted tokens for current year
    const mintedEvents = await contract.queryFilter(
      contract.filters.CardMinted(null, null, null, null, currentYear)
    );
    
    console.log(`Found ${mintedEvents.length} cards for ${currentYear}`);
    
    // Update each category
    await updateCastsLeaderboard(mintedEvents, currentYear);
    await updateLikesLeaderboard(mintedEvents, currentYear);
    await updateEngagementLeaderboard(mintedEvents, currentYear);
    await updateConsistencyLeaderboard(mintedEvents, currentYear);
    await updateRarityLeaderboard(mintedEvents, currentYear);
    await updateRoyaltyLeaderboard(currentYear);
    await updateValueLeaderboard(currentYear);
    
    console.log('Leaderboard update complete!');
    
  } catch (error) {
    console.error('Leaderboard update failed:', error);
  }
});

async function updateCastsLeaderboard(events, year) {
  const key = `leaderboard:casts:${year}`;
  
  // Clear existing data
  await redis.del(key);
  
  // Add all cards
  for (const event of events) {
    const tokenId = event.args.tokenId;
    const cardData = await contract.getCardData(tokenId);
    
    await redis.zadd(
      key,
      cardData.casts,
      `fid:${cardData.fid}`
    );
  }
  
  // Set expiry (7 days)
  await redis.expire(key, 7 * 24 * 60 * 60);
  
  console.log(`Updated casts leaderboard: ${events.length} entries`);
}

async function updateLikesLeaderboard(events, year) {
  const key = `leaderboard:likes:${year}`;
  await redis.del(key);
  
  for (const event of events) {
    const tokenId = event.args.tokenId;
    const cardData = await contract.getCardData(tokenId);
    
    await redis.zadd(
      key,
      cardData.likes,
      `fid:${cardData.fid}`
    );
  }
  
  await redis.expire(key, 7 * 24 * 60 * 60);
  console.log(`Updated likes leaderboard`);
}

async function updateEngagementLeaderboard(events, year) {
  const key = `leaderboard:engagement:${year}`;
  await redis.del(key);
  
  for (const event of events) {
    const tokenId = event.args.tokenId;
    const cardData = await contract.getCardData(tokenId);
    
    // Engagement rate = (replies + recasts) / casts * 100
    const engagementRate = cardData.casts > 0
      ? ((cardData.replies + cardData.recasts) / cardData.casts) * 100
      : 0;
    
    await redis.zadd(
      key,
      Math.round(engagementRate * 100), // Store as integer (2 decimals)
      `fid:${cardData.fid}`
    );
  }
  
  await redis.expire(key, 7 * 24 * 60 * 60);
  console.log(`Updated engagement leaderboard`);
}

async function updateConsistencyLeaderboard(events, year) {
  const key = `leaderboard:consistency:${year}`;
  await redis.del(key);
  
  for (const event of events) {
    const tokenId = event.args.tokenId;
    const cardData = await contract.getCardData(tokenId);
    
    // Only include perfect consistency (12/12)
    if (cardData.consistency === 12) {
      await redis.zadd(
        key,
        cardData.casts, // Secondary sort by casts
        `fid:${cardData.fid}`
      );
    }
  }
  
  await redis.expire(key, 7 * 24 * 60 * 60);
  console.log(`Updated consistency leaderboard`);
}

async function updateRarityLeaderboard(events, year) {
  const key = `leaderboard:rarity:${year}`;
  await redis.del(key);
  
  for (const event of events) {
    const tokenId = event.args.tokenId;
    const cardData = await contract.getCardData(tokenId);
    
    // Calculate rarity score (same formula as contract)
    const score = calculateRarityScore(cardData);
    
    await redis.zadd(
      key,
      score,
      `fid:${cardData.fid}`
    );
  }
  
  await redis.expire(key, 7 * 24 * 60 * 60);
  console.log(`Updated rarity leaderboard`);
}

async function updateRoyaltyLeaderboard(year) {
  const key = `leaderboard:royalty:${year}`;
  await redis.del(key);
  
  // Query OpenSea API for all sales
  const sales = await fetchAllSales(year);
  
  // Aggregate royalties by minter
  const royaltyByMinter = {};
  
  for (const sale of sales) {
    const tokenId = sale.tokenId;
    const cardData = await contract.getCardData(tokenId);
    const minter = cardData.minter;
    const royalty = sale.price * 0.03; // 3%
    
    royaltyByMinter[minter] = (royaltyByMinter[minter] || 0) + royalty;
  }
  
  // Add to leaderboard
  for (const [minter, totalRoyalty] of Object.entries(royaltyByMinter)) {
    await redis.zadd(
      key,
      Math.round(totalRoyalty * 1e18), // Store in wei
      minter
    );
  }
  
  await redis.expire(key, 7 * 24 * 60 * 60);
  console.log(`Updated royalty leaderboard: ${Object.keys(royaltyByMinter).length} minters`);
}

async function updateValueLeaderboard(year) {
  const key = `leaderboard:value:${year}`;
  await redis.del(key);
  
  // Query OpenSea API for highest sales
  const sales = await fetchAllSales(year);
  
  // Find highest sale per token
  const highestSaleByToken = {};
  
  for (const sale of sales) {
    const tokenId = sale.tokenId;
    const price = sale.price;
    
    if (!highestSaleByToken[tokenId] || price > highestSaleByToken[tokenId]) {
      highestSaleByToken[tokenId] = price;
    }
  }
  
  // Add to leaderboard
  for (const [tokenId, price] of Object.entries(highestSaleByToken)) {
    await redis.zadd(
      key,
      Math.round(price * 1e18), // Store in wei
      `token:${tokenId}`
    );
  }
  
  await redis.expire(key, 7 * 24 * 60 * 60);
  console.log(`Updated value leaderboard: ${Object.keys(highestSaleByToken).length} tokens`);
}

function calculateRarityScore(cardData) {
  const score = 
    Math.min((cardData.casts * 10) / 1000, 10) +
    Math.min((cardData.likes * 20) / 5000, 20) +
    Math.min((cardData.replies * 12) / 500, 12) +
    Math.min((cardData.recasts * 12) / 500, 12) +
    Math.min((cardData.followers * 8) / 200, 8) +
    (cardData.consistency * 20) / 12 +
    Math.min((cardData.uniqueInteractors * 18) / 300, 18);
  
  return Math.min(Math.round(score), 100);
}
```

API ENDPOINTS:

```javascript
// backend/routes/leaderboard.js

const express = require('express');
const router = express.Router();
const redis = require('../services/redis');
const { contract } = require('../services/contract');

/**
 * GET /api/leaderboard/:category
 * Returns top 100 for given category
 */
router.get('/:category', async (req, res) => {
  const { category } = req.params;
  const year = req.query.year || new Date().getUTCFullYear();
  
  // Validate category
  const validCategories = [
    'casts', 'likes', 'engagement', 'consistency',
    'rarity', 'royalty', 'value'
  ];
  
  if (!validCategories.includes(category)) {
    return res.status(400).json({ error: 'Invalid category' });
  }
  
  try {
    // Check cache first (1 hour TTL)
    const cacheKey = `api:leaderboard:${category}:${year}`;
    const cached = await redis.get(cacheKey);
    
    if (cached) {
      return res.json(JSON.parse(cached));
    }
    
    // Fetch from Redis sorted set
    const key = `leaderboard:${category}:${year}`;
    const entries = await redis.zrevrange(key, 0, 99, 'WITHSCORES');
    
    // Parse entries (Redis returns flat array: [member1, score1, member2, score2, ...])
    const leaderboard = [];
    for (let i = 0; i < entries.length; i += 2) {
      const identifier = entries[i];
      const score = parseInt(entries[i + 1]);
      
      // Extract FID or token ID
      const [type, id] = identifier.split(':');
      
      // Fetch additional data
      let userData;
      if (type === 'fid') {
        userData = await fetchUserData(parseInt(id));
      } else if (type === 'token') {
        userData = await fetchTokenData(parseInt(id));
      }
      
      leaderboard.push({
        rank: (i / 2) + 1,
        identifier,
        score: formatScore(score, category),
        ...userData
      });
    }
    
    const response = {
      category,
      year,
      leaderboard,
      updatedAt: new Date().toISOString()
    };
    
    // Cache for 1 hour
    await redis.setex(cacheKey, 3600, JSON.stringify(response));
    
    res.json(response);
    
  } catch (error) {
    console.error('Leaderboard fetch error:', error);
    res.status(500).json({ error: 'Failed to fetch leaderboard' });
  }
});

/**
 * GET /api/leaderboard/:category/user/:fid
 * Returns user's rank and score in category
 */
router.get('/:category/user/:fid', async (req, res) => {
  const { category, fid } = req.params;
  const year = req.query.year || new Date().getUTCFullYear();
  
  try {
    const key = `leaderboard:${category}:${year}`;
    const identifier = `fid:${fid}`;
    
    // Get rank (0-indexed)
    const rank = await redis.zrevrank(key, identifier);
    
    if (rank === null) {
      return res.json({
        fid: parseInt(fid),
        category,
        rank: null,
        score: null,
        message: 'Not on leaderboard'
      });
    }
    
    // Get score
    const score = await redis.zscore(key, identifier);
    
    // Get total entries
    const total = await redis.zcard(key);
    
    res.json({
      fid: parseInt(fid),
      category,
      rank: rank + 1, // Convert to 1-indexed
      score: formatScore(parseInt(score), category),
      total,
      percentile: Math.round((1 - rank / total) * 100)
    });
    
  } catch (error) {
    console.error('User rank fetch error:', error);
    res.status(500).json({ error: 'Failed to fetch user rank' });
  }
});

// Helper functions
async function fetchUserData(fid) {
  try {
    // Fetch from Neynar
    const response = await fetch(
      `https://api.neynar.com/v2/farcaster/user?fid=${fid}`,
      {
        headers: {
          'api_key': process.env.NEYNAR_API_KEY
        }
      }
    );
    
    const data = await response.json();
    const user = data.result.user;
    
    return {
      fid,
      username: user.username,
      displayName: user.display_name,
      pfpUrl: user.pfp_url
    };
  } catch (error) {
    return {
      fid,
      username: `user${fid}`,
      displayName: null,
      pfpUrl: null
    };
  }
}

async function fetchTokenData(tokenId) {
  try {
    const cardData = await contract.getCardData(tokenId);
    const userData = await fetchUserData(cardData.fid);
    
    return {
      tokenId,
      ...userData,
      rarityTier: getRarityTierName(cardData.rarityTier)
    };
  } catch (error) {
    return {
      tokenId,
      fid: null,
      username: null
    };
  }
}

function formatScore(score, category) {
  switch (category) {
    case 'engagement':
      return (score / 100).toFixed(2) + '%'; // Convert back from integer
    case 'royalty':
    case 'value':
      return ethers.formatEther(score) + ' ETH'; // Convert from wei
    default:
      return score; // Raw number for casts, likes, etc.
  }
}

function getRarityTierName(tier) {
  const names = ['Common', 'Uncommon', 'Rare', 'Epic', 'Legendary'];
  return names[tier] || 'Unknown';
}

module.exports = router;
```

FRAME INTEGRATION:

```javascript
// frame/routes/leaderboard.tsx

import { Button, Frog } from 'frog';

export const leaderboardRoute = new Frog()
  .frame('/leaderboard', async (c) => {
    const category = c.buttonValue || 'rarity';
    
    // Fetch leaderboard data
    const response = await fetch(
      `${process.env.API_URL}/api/leaderboard/${category}?year=2025`
    );
    const data = await response.json();
    
    // Render top 10 in frame
    const top10 = data.leaderboard.slice(0, 10);
    
    return c.res({
      image: (
        <div style={{
          display: 'flex',
          flexDirection: 'column',
          width: '100%',
          height: '100%',
          backgroundColor: '#1a1a1a',
          padding: '40px',
          fontFamily: 'Arial, sans-serif'
        }}>
          <h1 style={{ color: '#FFD700', fontSize: '48px', marginBottom: '20px' }}>
            ğŸ† Top 10 - {category.toUpperCase()}
          </h1>
          
          {top10.map((entry, i) => (
            <div key={i} style={{
              display: 'flex',
              justifyContent: 'space-between',
              color: '#fff',
              fontSize: '24px',
              marginBottom: '10px',
              padding: '10px',
              backgroundColor: i < 3 ? 'rgba(255,215,0,0.2)' : 'rgba(255,255,255,0.05)',
              borderRadius: '8px'
            }}>
              <span>#{entry.rank} @{entry.username}</span>
              <span style={{ fontWeight: 'bold' }}>{entry.score}</span>
            </div>
          ))}
        </div>
      ),
      intents: [
        <Button value="casts">ğŸ“Š Casts</Button>,
        <Button value="likes">â¤ï¸ Likes</Button>,
        <Button value="rarity">â­ Rarity</Button>,
        <Button value="royalty">ğŸ’° Royalty</Button>,
        <Button action="/">ğŸ  Home</Button>
      ]
    });
  });
```

LEADERBOARD DISPLAY EXAMPLE:

```
ğŸ† TOP 10 - RARITY SCORE (2025)

#1  @alice        92/100  â­ Legendary
#2  @bob          89/100  â­ Legendary
#3  @charlie      86/100  â­ Legendary
#4  @david        78/100  ğŸ’œ Epic
#5  @eve          76/100  ğŸ’œ Epic
#6  @frank        74/100  ğŸ’œ Epic
#7  @grace        68/100  ğŸ’™ Rare
#8  @henry        65/100  ğŸ’™ Rare
#9  @iris         63/100  ğŸ’™ Rare
#10 @jack         61/100  ğŸ’™ Rare

Your rank: #42 (58/100 - Rare)
You're in the top 15%!
```

GAMIFICATION ELEMENTS:

Badges for Top Performers:
- ğŸ¥‡ #1 Rank â†’ "Champion" badge
- ğŸ¥ˆ #2-3 â†’ "Elite" badge
- ğŸ¥‰ #4-10 â†’ "Top 10" badge
- ğŸ… #11-100 â†’ "Top 100" badge

Achievements:
- "Perfect Year" â†’ 12/12 consistency
- "Social Butterfly" â†’ 500+ unique interactors
- "Content King" â†’ 2000+ casts
- "Viral Legend" â†’ 20k+ likes
- "Early Adopter" â†’ FID < 10000


================================================================================
1ï¸âƒ£2ï¸âƒ£ FRAME INTEGRATION (FARCASTER)
================================================================================

TECHNOLOGY: Frog Framework (by Paradigm)

Setup:
```bash
npm install frog hono
```

FRAME STRUCTURE:

```
frame/
â”œâ”€â”€ index.ts                 # Main entry point
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ home.tsx             # Frame 1: Home/landing
â”‚   â”œâ”€â”€ preview.tsx          # Frame 2: Stats preview
â”‚   â”œâ”€â”€ mint.tsx             # Frame 3: Mint confirmation
â”‚   â”œâ”€â”€ success.tsx          # Frame 4: Post-mint success
â”‚   â””â”€â”€ leaderboard.tsx      # Bonus: Leaderboard view
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ StatsDisplay.tsx     # Reusable stats component
â”‚   â””â”€â”€ CardPreview.tsx      # SVG card preview
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ api.ts               # Backend API calls
â”‚   â””â”€â”€ formatting.ts        # Number/date formatting
â””â”€â”€ public/
    â””â”€â”€ og-image.png         # Open Graph image
```

FRAME 1: HOME

```typescript
// frame/routes/home.tsx

import { Button, Frog, TextInput } from 'frog';
import { handle } from 'frog/vercel';

export const app = new Frog({
  assetsPath: '/',
  basePath: '/api/frame',
  title: 'Farcaster Yearly Card'
});

app.frame('/', async (c) => {
  const { frameData } = c;
  const fid = frameData?.fid;
  
  if (!fid) {
    return c.res({
      image: (
        <div style={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          width: '100%',
          height: '100%',
          backgroundColor: '#1a1a1a',
          color: '#fff',
          fontFamily: 'Arial, sans-serif'
        }}>
          <h1 style={{ fontSize: '64px', marginBottom: '20px' }}>ğŸ´</h1>
          <h2 style={{ fontSize: '48px', marginBottom: '10px' }}>
            Farcaster Yearly Card
          </h2>
          <p style={{ fontSize: '24px', color: '#aaa' }}>
            Turn your social stats into a collectible NFT
          </p>
        </div>
      ),
      intents: [
        <Button action="/check">Check Eligibility</Button>
      ]
    });
  }
  
  // Check eligibility
  const response = await fetch(
    `${process.env.API_URL}/api/stats/${fid}`
  );
  
  if (!response.ok) {
    const error = await response.json();
    return c.res({
      image: (
        <div style={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          width: '100%',
          height: '100%',
          backgroundColor: '#1a1a1a',
          color: '#fff'
        }}>
          <h2 style={{ fontSize: '48px', color: '#ff6b6b' }}>âŒ Not Eligible</h2>
          <p style={{ fontSize: '24px', marginTop: '20px' }}>{error.error}</p>
          <p style={{ fontSize: '20px', color: '#aaa', marginTop: '10px' }}>
            {error.nextEligible && `Next eligible: ${error.nextEligible}`}
          </p>
        </div>
      ),
      intents: [
        <Button action="/leaderboard">View Leaderboard</Button>
      ]
    });
  }
  
  const { stats, rarityTier, canMint } = await response.json();
  
  return c.res({
    image: (
      <div style={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        width: '100%',
        height: '100%',
        backgroundColor: '#1a1a1a',
        color: '#fff',
        padding: '40px'
      }}>
        <h1 style={{ fontSize: '56px', marginBottom: '20px' }}>
          ğŸ´ Ready to Mint!
        </h1>
        <div style={{
          backgroundColor: 'rgba(255,255,255,0.1)',
          padding: '30px',
          borderRadius: '15px',
          marginBottom: '20px'
        }}>
          <p style={{ fontSize: '32px', marginBottom: '10px' }}>
            Your predicted tier:
          </p>
          <p style={{ fontSize: '48px', fontWeight: 'bold', color: getRarityColor(rarityTier) }}>
            {rarityTier.toUpperCase()}
          </p>
        </div>
        <p style={{ fontSize: '24px', color: '#aaa' }}>
          Mint fee: 0.0005 ETH + gas (~$2.10 total)
        </p>
      </div>
    ),
    intents: [
      <Button action="/preview">Preview Stats</Button>,
      <Button action="/leaderboard">Leaderboard</Button>
    ]
  });
});
```

FRAME 2: STATS PREVIEW

```typescript
// frame/routes/preview.tsx

app.frame('/preview', async (c) => {
  const { frameData } = c;
  const fid = frameData?.fid;
  
  // Fetch stats
  const response = await fetch(`${process.env.API_URL}/api/stats/${fid}`);
  const { stats, rarityScore, rarityTier } = await response.json();
  
  return c.res({
    image: (
      <div style={{
        display: 'flex',
        flexDirection: 'column',
        width: '100%',
        height: '100%',
        backgroundColor: '#1a1a1a',
        color: '#fff',
        padding: '40px',
        fontFamily: 'Arial, sans-serif'
      }}>
        <h1 style={{ fontSize: '48px', marginBottom: '30px' }}>
          ğŸ“Š Your 2025 Stats
        </h1>
        
        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '20px' }}>
          <StatBox label="Casts" value={stats.casts} />
          <StatBox label="Likes" value={stats.likes} />
          <StatBox label="Replies" value={stats.replies} />
          <StatBox label="Recasts" value={stats.recasts} />
          <StatBox label="Followers" value={`+${stats.followers}`} />
          <StatBox label="Consistency" value={`${stats.consistency}/12`} />
        </div>
        
        <div style={{
          marginTop: '30px',
          padding: '20px',
          backgroundColor: getRarityColor(rarityTier) + '33',
          borderRadius: '10px',
          border: `3px solid ${getRarityColor(rarityTier)}`
        }}>
          <p style={{ fontSize: '24px' }}>Rarity: {rarityTier.toUpperCase()}</p>
          <p style={{ fontSize: '32px', fontWeight: 'bold' }}>
            Score: {rarityScore}/100
          </p>
        </div>
      </div>
    ),
    intents: [
      <Button.Transaction target="/mint">Mint Now (0.0005 ETH)</Button.Transaction>,
      <Button action="/">Back</Button>
    ]
  });
});

function StatBox({ label, value }: { label: string; value: string | number }) {
  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      backgroundColor: 'rgba(255,255,255,0.05)',
      padding: '15px',
      borderRadius: '8px',
      minWidth: '150px'
    }}>
      <span style={{ fontSize: '16px', color: '#999' }}>{label}</span>
      <span style={{ fontSize: '32px', fontWeight: 'bold', marginTop: '5px' }}>
        {value}
      </span>
    </div>
  );
}
```

FRAME 3: MINT TRANSACTION

```typescript
// frame/routes/mint.tsx

import { Button, Frog } from 'frog';
import { parseEther } from 'viem';

app.transaction('/mint', async (c) => {
  const { frameData } = c;
  const fid = frameData?.fid;
  
  // Fetch stats with signature
  const response = await fetch(`${process.env.API_URL}/api/stats/${fid}`);
  const { stats, signature } = await response.json();
  
  // Return transaction data
  return c.contract({
    abi: contractABI,
    chainId: 'eip155:8453', // Base
    functionName: 'mint',
    args: [
      stats.fid,
      stats.username,
      stats.casts,
      stats.likes,
      stats.replies,
      stats.recasts,
      stats.followers,
      stats.consistency,
      stats.uniqueInteractors,
      signature
    ],
    to: process.env.CONTRACT_ADDRESS as `0x${string}`,
    value: parseEther('0.0005')
  });
});
```

FRAME 4: SUCCESS

```typescript
// frame/routes/success.tsx

app.frame('/success/:tokenId', async (c) => {
  const { tokenId } = c.req.param();
  
  // Fetch card data
  const tokenURI = await contract.tokenURI(tokenId);
  const metadata = JSON.parse(
    Buffer.from(tokenURI.split(',')[1], 'base64').toString()
  );
  
  return c.res({
    image: metadata.image, // Display the actual SVG card
    intents: [
      <Button.Link href={`https://basescan.org/token/${process.env.CONTRACT_ADDRESS}?a=${tokenId}`}>
        View on BaseScan
      </Button.Link>,
      <Button.Link href={`https://opensea.io/assets/base/${process.env.CONTRACT_ADDRESS}/${tokenId}`}>
        View on OpenSea
      </Button.Link>,
      <Button action="/share">Share to Farcaster</Button>,
      <Button action="/">Mint Another (if eligible)</Button>
    ]
  });
});
```

FRAME 5: SHARE (Post-Mint Cast)

```typescript
app.frame('/share/:tokenId', async (c) => {
  const { tokenId } = c.req.param();
  const { frameData } = c;
  
  // Fetch card data for share text
  const response = await fetch(
    `${process.env.API_URL}/api/card/${tokenId}`
  );
  const { rarityTier, stats } = await response.json();
  
  // Generate share cast
  const shareText = `I just minted my 2025 Farcaster Yearly Card! ğŸ´

â­ ${rarityTier.toUpperCase()} Tier
ğŸ“Š ${stats.casts} casts â€¢ ${stats.likes} likes â€¢ ${stats.consistency}/12 consistency

Mint yours â†’ ${process.env.FRAME_URL}`;
  
  // Use Warpcast composer API
  const composerUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(shareText)}&embeds[]=${encodeURIComponent(process.env.FRAME_URL)}`;
  
  return c.res({
    image: (
      <div style={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        width: '100%',
        height: '100%',
        backgroundColor: '#1a1a1a',
        color: '#fff'
      }}>
        <h1 style={{ fontSize: '56px', marginBottom: '20px' }}>ğŸ‰ Success!</h1>
        <p style={{ fontSize: '28px', textAlign: 'center', maxWidth: '600px' }}>
          Your card has been minted!
          Share it with your followers.
        </p>
      </div>
    ),
    intents: [
      <Button.Link href={composerUrl}>Share to Farcaster</Button.Link>,
      <Button action="/">Home</Button>
    ]
  });
});
```

DEPLOYMENT (Vercel):

```typescript
// frame/api/[[...routes]]/route.tsx

import { handle } from 'frog/vercel';
import { app } from '../../index';

export const GET = handle(app);
export const POST = handle(app);
```

vercel.json:
```json
{
  "rewrites": [
    {
      "source": "/api/frame/:path*",
      "destination": "/api/[[...routes]]"
    }
  ]
}
```

FRAME METADATA (for Warpcast):

```html
<meta property="fc:frame" content="vNext" />
<meta property="fc:frame:image" content="https://yearly.cards/og-image.png" />
```html
fc:frame:button:1" content="Check Eligibility" />
<meta property="fc:frame:button:1:action" content="post" />
<meta property="fc:frame:button:2" content="View Leaderboard" />
<meta property="fc:frame:button:2:action" content="post" />
<meta property="fc:frame:post_url" content="https://yearly.cards/api/frame" />
<meta property="og:title" content="Farcaster Yearly Card" />
<meta property="og:description" content="Turn your Farcaster activity into a collectible NFT" />
<meta property="og:image" content="https://yearly.cards/og-image.png" />
```

HELPER UTILITIES:

```typescript
// frame/utils/api.ts

export async function fetchStats(fid: number) {
  const response = await fetch(
    `${process.env.API_URL}/api/stats/${fid}`
  );
  
  if (!response.ok) {
    throw new Error('Failed to fetch stats');
  }
  
  return response.json();
}

export async function verifyTransaction(txHash: string) {
  const response = await fetch(
    `${process.env.API_URL}/api/verify`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ txHash })
    }
  );
  
  return response.json();
}
```

```typescript
// frame/utils/formatting.ts

export function formatNumber(num: number): string {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(1) + 'M';
  }
  if (num >= 1000) {
    return (num / 1000).toFixed(1) + 'K';
  }
  return num.toString();
}

export function getRarityColor(tier: string): string {
  const colors: Record<string, string> = {
    'legendary': '#FFD700',
    'epic': '#9B59B6',
    'rare': '#3498DB',
    'uncommon': '#2ECC71',
    'common': '#95A5A6'
  };
  return colors[tier.toLowerCase()] || '#95A5A6';
}

export function formatDate(timestamp: number): string {
  const date = new Date(timestamp * 1000);
  return date.toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  });
}
```

TESTING:

```bash
# Local development
npm run dev

# Test in Warpcast Frame Validator
# https://warpcast.com/~/developers/frames

# Deploy to Vercel
vercel deploy --prod
```


================================================================================
1ï¸âƒ£3ï¸âƒ£ ECONOMIC MODEL & SUSTAINABILITY
================================================================================

REVENUE STREAMS:

1. PRIMARY: Mint Fees
   â””â”€ 0.0005 ETH per mint
   â””â”€ 100% to protocol treasury

2. SECONDARY: None (all royalties to minters)
   â””â”€ Sustainable through volume

COST STRUCTURE:

Monthly Operating Costs (Estimated):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Service               â”‚ Plan              â”‚ Cost/Month         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Backend Hosting       â”‚ Railway Pro       â”‚ $20                â”‚
â”‚ Redis Cache           â”‚ Upstash Free      â”‚ $0                 â”‚
â”‚ Neynar API            â”‚ Growth            â”‚ $50                â”‚
â”‚ Domain & CDN          â”‚ Vercel Pro        â”‚ $20                â”‚
â”‚ Contract Deployment   â”‚ One-time          â”‚ $30 (amortized)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ TOTAL                 â”‚                   â”‚ ~$90/month         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Break-Even Analysis:
- Monthly costs: $90
- Revenue per mint: ~$1.50 (at $3000 ETH)
- Break-even: 60 mints/month
- Daily target: 2 mints/day

REVENUE PROJECTIONS:

Conservative Scenario (Year 1):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Month    â”‚ Mints â”‚ Revenue  â”‚ Costs â”‚ Net Profit â”‚ Cumulative â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Month 1  â”‚   50  â”‚   $75    â”‚  $90  â”‚   -$15     â”‚   -$15     â”‚
â”‚ Month 2  â”‚   80  â”‚  $120    â”‚  $90  â”‚   +$30     â”‚   +$15     â”‚
â”‚ Month 3  â”‚  120  â”‚  $180    â”‚  $90  â”‚   +$90     â”‚  +$105     â”‚
â”‚ Month 4  â”‚  150  â”‚  $225    â”‚  $90  â”‚  +$135     â”‚  +$240     â”‚
â”‚ Month 5  â”‚  180  â”‚  $270    â”‚  $90  â”‚  +$180     â”‚  +$420     â”‚
â”‚ Month 6  â”‚  200  â”‚  $300    â”‚  $90  â”‚  +$210     â”‚  +$630     â”‚
â”‚ Month 7  â”‚  220  â”‚  $330    â”‚  $90  â”‚  +$240     â”‚  +$870     â”‚
â”‚ Month 8  â”‚  240  â”‚  $360    â”‚  $90  â”‚  +$270     â”‚ +$1,140    â”‚
â”‚ Month 9  â”‚  260  â”‚  $390    â”‚  $90  â”‚  +$300     â”‚ +$1,440    â”‚
â”‚ Month 10 â”‚  280  â”‚  $420    â”‚  $90  â”‚  +$330     â”‚ +$1,770    â”‚
â”‚ Month 11 â”‚  300  â”‚  $450    â”‚  $90  â”‚  +$360     â”‚ +$2,130    â”‚
â”‚ Month 12 â”‚  350  â”‚  $525    â”‚  $90  â”‚  +$435     â”‚ +$2,565    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ TOTAL Y1 â”‚ 2,430 â”‚ $3,645   â”‚ $1,080â”‚ +$2,565    â”‚            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Moderate Scenario (Year 1):
- 5,000 total mints
- Revenue: $7,500
- Costs: $1,080
- Net: $6,420
- Avg: 416 mints/month

Optimistic Scenario (Year 1):
- 10,000 total mints
- Revenue: $15,000
- Costs: $1,080
- Net: $13,920
- Avg: 833 mints/month

USER ECONOMICS:

Mint Decision Calculator:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User invests: $2.10 (fee + gas)                               â”‚
â”‚                                                                 â”‚
â”‚ Receives:                                                       â”‚
â”‚ âœ… Unique NFT (collectible value)                              â”‚
â”‚ âœ… Social proof (on-chain stats)                               â”‚
â”‚ âœ… 3% perpetual royalties (passive income)                     â”‚
â”‚ âœ… Trading rights (can flip on OpenSea)                        â”‚
â”‚                                                                 â”‚
â”‚ Payback scenarios:                                              â”‚
â”‚ â€¢ 3 sales at $25 each â†’ $2.25 royalty (ROI: +7%)              â”‚
â”‚ â€¢ 5 sales at $30 each â†’ $4.50 royalty (ROI: +114%)            â”‚
â”‚ â€¢ 10 sales at $50 each â†’ $15 royalty (ROI: +614%)             â”‚
â”‚                                                                 â”‚
â”‚ Risk: Low (sunk cost only $2.10)                               â”‚
â”‚ Upside: Medium-High (based on card rarity & trading)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SECONDARY MARKET PROJECTIONS:

Assumptions:
- 30% of minted cards trade at least once
- Average first sale: $20-30 (2-3x mint cost)
- Legendary cards: $50-200 (premium)
- Common cards: $10-15 (below average)

Secondary Market Impact on Minters:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Scenario             â”‚ Sales â”‚ Avg Price â”‚ Total Royalty      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ No trading           â”‚   0   â”‚    -      â”‚    $0              â”‚
â”‚ Low activity         â”‚   2   â”‚   $20     â”‚    $1.20           â”‚
â”‚ Medium activity      â”‚   5   â”‚   $30     â”‚    $4.50           â”‚
â”‚ High activity        â”‚  10   â”‚   $40     â”‚   $12.00           â”‚
â”‚ Viral card (rare)    â”‚  20   â”‚  $100     â”‚   $60.00           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SUSTAINABILITY METRICS:

Key Performance Indicators (KPIs):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Metric                    â”‚ Target (Month 6)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Monthly active minters    â”‚ 200+                               â”‚
â”‚ Repeat minters (Year 2)   â”‚ 60% retention                      â”‚
â”‚ Secondary trading volume  â”‚ 30% of supply                      â”‚
â”‚ Average card price        â”‚ $25-30 (2-3x mint cost)            â”‚
â”‚ Legendary card premium    â”‚ 3-5x average                       â”‚
â”‚ Community engagement      â”‚ 500+ Discord/Telegram members      â”‚
â”‚ Frame views               â”‚ 10,000+ per month                  â”‚
â”‚ API uptime                â”‚ 99.9%                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

GROWTH STRATEGY:

Phase 1: Launch (Month 1-3)
â”œâ”€ Target: Early adopters & Farcaster OGs
â”œâ”€ Marketing: Organic sharing + partnerships
â”œâ”€ Goal: 300 mints, establish product-market fit
â””â”€ Budget: $0 (organic growth)

Phase 2: Growth (Month 4-6)
â”œâ”€ Target: Active Farcaster users
â”œâ”€ Marketing: Influencer campaigns + contests
â”œâ”€ Goal: 600 mints, build community
â””â”€ Budget: $500 (paid marketing)

Phase 3: Scale (Month 7-12)
â”œâ”€ Target: Broader crypto community
â”œâ”€ Marketing: Cross-platform promotion
â”œâ”€ Goal: 1,500 mints, mainstream awareness
â””â”€ Budget: $1,500 (paid + sponsored content)

MONETIZATION ALTERNATIVES (Future):

Potential additional revenue streams:
1. Premium Features ($5-10/month subscription)
   â”œâ”€ Advanced analytics dashboard
   â”œâ”€ Historical card comparison
   â””â”€ Early access to special editions

2. Special Edition Cards ($10-50 per mint)
   â”œâ”€ Event-specific (Farcon, etc.)
   â”œâ”€ Collaboration editions
   â””â”€ Limited run (100 mints max)

3. White Label (B2B)
   â”œâ”€ Custom cards for DAOs/protocols
   â”œâ”€ Setup fee: $5,000
   â””â”€ Revenue share: 20%

4. API Access (Developers)
   â”œâ”€ Free tier: 1,000 calls/month
   â”œâ”€ Pro tier: $20/month (unlimited)
   â””â”€ Target: Analytics platforms, apps

FINANCIAL SAFETY NETS:

Risk Mitigation:
âœ… Low operating costs ($90/month sustainable)
âœ… Break-even at only 60 mints/month
âœ… No dependencies on external funding
âœ… Scalable infrastructure (serverless)
âœ… Emergency fund: 6 months costs ($540)

Exit Strategy (if needed):
1. Open source the codebase
2. Transfer contract ownership to community multisig
3. Documentation for self-hosting
4. Archive data on IPFS/Arweave

LONG-TERM VISION (3-5 Years):

Year 2: Multi-chain expansion
â”œâ”€ Deploy on Optimism, Arbitrum
â”œâ”€ Cross-chain card collections
â””â”€ Estimated: 20,000 mints/year

Year 3: Social graph integration
â”œâ”€ Follow/unfollow tracking
â”œâ”€ Network growth visualization
â””â”€ Estimated: 50,000 mints/year

Year 4: Interoperability
â”œâ”€ Cards usable across protocols
â”œâ”€ Reputation scoring system
â””â”€ Estimated: 100,000+ mints/year

TREASURY MANAGEMENT:

Protocol Treasury Allocation:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Purpose              â”‚ Allocation â”‚ Amount (after 1000 mints) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Operating Reserve    â”‚    40%     â”‚    $600                   â”‚
â”‚ Development Fund     â”‚    30%     â”‚    $450                   â”‚
â”‚ Marketing            â”‚    20%     â”‚    $300                   â”‚
â”‚ Emergency Fund       â”‚    10%     â”‚    $150                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Withdrawal Strategy:
- Monthly: Operating costs only ($90)
- Quarterly: Development + marketing budgets
- Reserve: Maintained at 6 months runway
- Excess: Reinvested in product improvements


================================================================================
1ï¸âƒ£4ï¸âƒ£ DEPLOYMENT GUIDE
================================================================================

PREREQUISITES:

Required Tools:
- Node.js 18+ LTS
- npm or yarn
- Git
- Wallet with Base ETH (~0.05 ETH for deployment)

Required Accounts:
- Neynar API key (https://neynar.com)
- Vercel account (for Frame hosting)
- Railway/Render account (for backend)
- Upstash Redis (free tier)

STEP-BY-STEP DEPLOYMENT:

STEP 1: SMART CONTRACT DEPLOYMENT

1.1 Setup Hardhat Project
```bash
mkdir farcaster-yearly-card
cd farcaster-yearly-card
npm init -y
npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox
npx hardhat init
```

1.2 Configure Hardhat
```javascript
// hardhat.config.js

require("@nomicfoundation/hardhat-toolbox");
require("dotenv").config();

module.exports = {
  solidity: {
    version: "0.8.20",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200
      }
    }
  },
  networks: {
    base: {
      url: "https://mainnet.base.org",
      accounts: [process.env.DEPLOYER_PRIVATE_KEY],
      chainId: 8453
    },
    baseGoerli: {
      url: "https://goerli.base.org",
      accounts: [process.env.DEPLOYER_PRIVATE_KEY],
      chainId: 84531
    }
  },
  etherscan: {
    apiKey: {
      base: process.env.BASESCAN_API_KEY
    },
    customChains: [
      {
        network: "base",
        chainId: 8453,
        urls: {
          apiURL: "https://api.basescan.org/api",
          browserURL: "https://basescan.org"
        }
      }
    ]
  }
};
```

1.3 Create .env File
```bash
DEPLOYER_PRIVATE_KEY=your_private_key_here
STATS_ORACLE_ADDRESS=your_backend_address_here
BASESCAN_API_KEY=your_basescan_key_here
```

1.4 Deploy Script
```javascript
// scripts/deploy.js

const hre = require("hardhat");

async function main() {
  console.log("Deploying Farcaster Yearly Card...");
  
  const statsOracle = process.env.STATS_ORACLE_ADDRESS;
  
  if (!statsOracle) {
    throw new Error("STATS_ORACLE_ADDRESS not set in .env");
  }
  
  // Deploy contract
  const FarcasterYearlyCard = await hre.ethers.getContractFactory("FarcasterYearlyCard");
  const contract = await FarcasterYearlyCard.deploy(statsOracle);
  
  await contract.waitForDeployment();
  
  const address = await contract.getAddress();
  console.log("Contract deployed to:", address);
  
  // Wait for block confirmations
  console.log("Waiting for block confirmations...");
  await contract.deploymentTransaction().wait(5);
  
  // Verify on BaseScan
  console.log("Verifying contract...");
  await hre.run("verify:verify", {
    address: address,
    constructorArguments: [statsOracle]
  });
  
  console.log("Deployment complete!");
  console.log("Contract address:", address);
  console.log("Stats oracle:", statsOracle);
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

1.5 Deploy to Base
```bash
# Test on Base Goerli first
npx hardhat run scripts/deploy.js --network baseGoerli

# If successful, deploy to mainnet
npx hardhat run scripts/deploy.js --network base
```

Expected output:
```
Deploying Farcaster Yearly Card...
Contract deployed to: 0x1234567890abcdef...
Waiting for block confirmations...
Verifying contract...
Successfully verified contract
Deployment complete!
```

Cost: ~2.5M gas = ~$25-35 on Base

STEP 2: BACKEND API DEPLOYMENT

2.1 Setup Express Backend
```bash
mkdir backend
cd backend
npm init -y
npm install express ethers dotenv cors redis @neynar/nodejs-sdk
```

2.2 Environment Variables
```bash
# backend/.env

PORT=3000
NODE_ENV=production

# Contract
CONTRACT_ADDRESS=0x...
CHAIN_ID=8453

# Oracle
STATS_ORACLE_PRIVATE_KEY=0x...

# Neynar API
NEYNAR_API_KEY=your_neynar_key

# Redis
REDIS_URL=redis://default:password@host:port

# CORS
ALLOWED_ORIGINS=https://yearly.cards,https://warpcast.com
```

2.3 Deploy to Railway
```bash
# Install Railway CLI
npm install -g @railway/cli

# Login
railway login

# Initialize project
railway init

# Deploy
railway up
```

Railway Configuration:
- Service: Node.js
- Build Command: `npm install`
- Start Command: `node index.js`
- Environment: Copy all .env variables
- Region: US West (closest to Base RPC)

Cost: $5-20/month (Railway Hobby/Pro)

STEP 3: REDIS SETUP

3.1 Create Upstash Redis
```bash
# Go to https://upstash.com
# Create new database
# Copy REDIS_URL

# Test connection
redis-cli -u $REDIS_URL
> PING
PONG
```

3.2 Initialize Data
```bash
# Run initial leaderboard setup
node scripts/initializeLeaderboards.js
```

Cost: $0 (free tier sufficient for launch)

STEP 4: FRAME DEPLOYMENT

4.1 Setup Frog Project
```bash
mkdir frame
cd frame
npm create frog
# Choose: Vercel template
```

4.2 Configure Environment
```bash
# frame/.env.local

NEXT_PUBLIC_FRAME_URL=https://yearly.cards
API_URL=https://api.yearly.cards
CONTRACT_ADDRESS=0x...
CHAIN_ID=8453
```

4.3 Deploy to Vercel
```bash
# Install Vercel CLI
npm i -g vercel

# Login
vercel login

# Deploy
vercel --prod
```

Vercel Configuration:
- Framework: Next.js
- Build Command: `npm run build`
- Output Directory: `.next`
- Install Command: `npm install`
- Environment Variables: Add all from .env.local

Cost: $0-20/month (Hobby/Pro tier)

STEP 5: DOMAIN SETUP

5.1 Purchase Domain
- yearly.cards (recommended)
- or farcastercard.xyz
- or similar

5.2 Configure DNS
```
Type    Name    Value
A       @       76.76.21.21 (Vercel)
CNAME   api     api-railway.up.railway.app
CNAME   www     cname.vercel-dns.com
```

5.3 SSL Certificates
- Vercel: Auto-configured
- Railway: Enable custom domain in settings

STEP 6: VERIFICATION & TESTING

6.1 Test Contract
```bash
npx hardhat test
npx hardhat run scripts/testMint.js --network base
```

6.2 Test Backend API
```bash
curl https://api.yearly.cards/api/stats/3
curl https://api.yearly.cards/api/leaderboard/rarity
```

6.3 Test Frame
```bash
# Warpcast Frame Validator
https://warpcast.com/~/developers/frames

# Enter: https://yearly.cards
# Test all buttons and flows
```

6.4 End-to-End Test
1. Open frame in Warpcast
2. Check eligibility
3. Preview stats
4. Mint (testnet first!)
5. Verify NFT on BaseScan
6. Check OpenSea listing
7. Test share functionality

STEP 7: MONITORING SETUP

7.1 Contract Monitoring
```javascript
// scripts/monitor.js

const { ethers } = require("ethers");

const provider = new ethers.JsonRpcProvider("https://mainnet.base.org");
const contract = new ethers.Contract(ADDRESS, ABI, provider);

contract.on("CardMinted", (tokenId, fid, minter, rarityTier, year) => {
  console.log(`New mint: Token #${tokenId}, FID ${fid}, Tier ${rarityTier}`);
  // Send notification (Discord webhook, etc.)
});
```

7.2 API Monitoring
- Uptime: UptimeRobot (free, 50 monitors)
- Errors: Sentry (free tier)
- Analytics: Plausible/Fathom

7.3 Alerts
```javascript
// Set up Discord webhook for critical events
const DISCORD_WEBHOOK = process.env.DISCORD_WEBHOOK;

async function sendAlert(message) {
  await fetch(DISCORD_WEBHOOK, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content: message })
  });
}
```

DEPLOYMENT CHECKLIST:

Pre-Launch:
â˜ Contract deployed and verified on BaseScan
â˜ Backend API running and accessible
â˜ Redis populated with initial data
â˜ Frame deployed and validated
â˜ Domain configured with SSL
â˜ Environment variables set correctly
â˜ Test mint completed successfully
â˜ OpenSea metadata displaying correctly
â˜ Royalty system tested
â˜ Leaderboard updating
â˜ Monitoring/alerts configured

Launch:
â˜ Announce in Farcaster
â˜ Submit frame to Warpcast directory
â˜ Post in /dev and /founders channels
â˜ Share on Twitter/X
â˜ Monitor for first 24 hours
â˜ Gather user feedback
â˜ Fix any critical bugs immediately

Post-Launch:
â˜ Daily stats review
â˜ Weekly leaderboard updates
â˜ Monthly cost analysis
â˜ Quarterly feature releases
â˜ Continuous community engagement

TROUBLESHOOTING GUIDE:

Issue: Contract deployment fails
Solution:
- Check deployer wallet has sufficient Base ETH
- Verify RPC endpoint is responsive
- Reduce optimizer runs if contract too large

Issue: Signature verification fails
Solution:
- Ensure statsOracle address matches backend wallet
- Check signature format (should be 65 bytes)
- Verify hash includes all parameters in correct order

Issue: Frame not rendering
Solution:
- Validate meta tags with Warpcast validator
- Check image URLs are publicly accessible
- Ensure CORS headers allow frame domain

Issue: Stats fetch timeout
Solution:
- Implement caching (1 hour TTL)
- Add retry logic with exponential backoff
- Consider Neynar API rate limits

Issue: High gas costs
Solution:
- Review data packing implementation
- Check for unnecessary SSTORE operations
- Consider batch processing for admin functions


================================================================================
1ï¸âƒ£5ï¸âƒ£ TESTING STRATEGY
================================================================================

TESTING LAYERS:

1. Unit Tests (Smart Contract)
2. Integration Tests (Backend API)
3. End-to-End Tests (Full Flow)
4. Security Audits
5. User Acceptance Testing

UNIT TESTS (Hardhat):

```javascript
// test/FarcasterYearlyCard.test.js

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("FarcasterYearlyCard", function () {
  let contract;
  let owner, user1, user2, statsOracle;
  
  beforeEach(async function () {
    [owner, user1, user2, statsOracle] = await ethers.getSigners();
    
    const FarcasterYearlyCard = await ethers.getContractFactory("FarcasterYearlyCard");
    contract = await FarcasterYearlyCard.deploy(statsOracle.address);
    await contract.waitForDeployment();
  });
  
  describe("Deployment", function () {
    it("Should set the correct stats oracle", async function () {
      expect(await contract.statsOracle()).to.equal(statsOracle.address);
    });
    
    it("Should set correct mint fee", async function () {
      expect(await contract.MINT_FEE()).to.equal(ethers.parseEther("0.0005"));
    });
    
    it("Should set correct royalty BPS", async function () {
      expect(await contract.ROYALTY_BPS()).to.equal(300);
    });
  });
  
  describe("Minting", function () {
    it("Should mint a card with valid signature", async function () {
      const fid = 12345;
      const username = "alice";
      const stats = {
        casts: 1000,
        likes: 5000,
        replies: 500,
        recasts: 300,
        followers: 200,
        consistency: 12,
        uniqueInteractors: 300
      };
      
      // Generate signature
      const year = Math.floor(Date.now() / (365 * 24 * 60 * 60 * 1000)) + 1970;
      const hash = ethers.solidityPackedKeccak256(
        ['uint32', 'string', 'uint16', 'uint16', 'uint16', 'uint16', 'uint16', 'uint8', 'uint32', 'uint16'],
        [fid, username, stats.casts, stats.likes, stats.replies, stats.recasts, stats.followers, stats.consistency, stats.uniqueInteractors, year]
      );
      
      const signature = await statsOracle.signMessage(ethers.getBytes(hash));
      
      // Mint
      await expect(
        contract.connect(user1).mint(
          fid,
          username,
          stats.casts,
          stats.likes,
          stats.replies,
          stats.recasts,
          stats.followers,
          stats.consistency,
          stats.uniqueInteractors,
          signature,
          { value: ethers.parseEther("0.0005") }
        )
      ).to.emit(contract, "CardMinted");
      
      // Verify ownership
      expect(await contract.ownerOf(1)).to.equal(user1.address);
    });
    
    it("Should reject mint with invalid fee", async function () {
      // ... test code ...
      await expect(
        contract.connect(user1).mint(...)
          .withArgs({ value: ethers.parseEther("0.0001") })
      ).to.be.revertedWith("Invalid mint fee");
    });
    
    it("Should reject double mint in same year", async function () {
      // Mint once
      await contract.connect(user1).mint(...);
      
      // Try to mint again
      await expect(
        contract.connect(user1).mint(...)
      ).to.be.revertedWith("Already minted this year");
    });
    
    it("Should reject mint with invalid signature", async function () {
      const fakeSignature = "0x" + "00".repeat(65);
      
      await expect(
        contract.connect(user1).mint(..., fakeSignature, ...)
      ).to.be.revertedWith("Invalid signature");
    });
  });
  
  describe("Rarity Calculation", function () {
    it("Should calculate Legendary tier correctly", async function () {
      const stats = {
        casts: 2000,
        likes: 10000,
        replies: 800,
        recasts: 700,
        followers: 300,
        consistency: 12,
        uniqueInteractors: 400
      };
      
      // Mint and check rarity
      await contract.connect(user1).mint(...);
      const card = await contract.getCardData(1);
      
      expect(card.rarityTier).to.equal(4); // Legendary
    });
    
    it("Should calculate Common tier correctly", async function () {
      const stats = {
        casts: 50,
        likes: 100,
        replies: 10,
        recasts: 5,
        followers: 10,
        consistency: 3,
        uniqueInteractors: 20
      };
      
      await contract.connect(user1).mint(...);
      const card = await contract.getCardData(1);
      
      expect(card.rarityTier).to.equal(0); // Common
    });
  });
  
  describe("Royalty System", function () {
    it("Should return correct royalty info", async function () {
      // Mint card
      await contract.connect(user1).mint(...);
      
      // Check royalty
      const salePrice = ethers.parseEther("1");
      const [receiver, amount] = await contract.royaltyInfo(1, salePrice);
      
      expect(receiver).to.equal(user1.address);
      expect(amount).to.equal(ethers.parseEther("0.03")); // 3% of 1 ETH
    });
    
    it("Should maintain minter as royalty receiver after transfer", async function () {
      // Mint card
      await contract.connect(user1).mint(...);
      
      // Transfer to user2
      await contract.connect(user1).transferFrom(user1.address, user2.address, 1);
      
      // Check royalty still goes to user1
      const [receiver, ] = await contract.royaltyInfo(1, ethers.parseEther("1"));
      expect(receiver).to.equal(user1.address);
    });
  });
  
  describe("TokenURI", function () {
    it("Should generate valid metadata JSON", async function () {
      await contract.connect(user1).mint(...);
      
      const tokenURI = await contract.tokenURI(1);
      expect(tokenURI).to.include("data:application/json;base64");
      
      // Decode and parse
      const json = Buffer.from(
        tokenURI.split(',')[1],
        'base64'
      ).toString();
      
      const metadata = JSON.parse(json);
      expect(metadata).to.have.property('name`);
      expect(metadata).to.have.property('image');
      expect(metadata).to.have.property('attributes');
      expect(metadata.image).to.include('data:image/svg+xml;base64');
    });
    
    it("Should include all stats in attributes", async function () {
      await contract.connect(user1).mint(...);
      
      const tokenURI = await contract.tokenURI(1);
      const json = Buffer.from(tokenURI.split(',')[1], 'base64').toString();
      const metadata = JSON.parse(json);
      
      const traitTypes = metadata.attributes.map(attr => attr.trait_type);
      expect(traitTypes).to.include('FID');
      expect(traitTypes).to.include('Casts');
      expect(traitTypes).to.include('Likes Received');
      expect(traitTypes).to.include('Rarity Tier');
    });
  });
  
  describe("Eligibility", function () {
    it("Should allow mint after year change", async function () {
      // Mint in current year
      await contract.connect(user1).mint(...);
      
      // Fast forward 1 year
      await ethers.provider.send("evm_increaseTime", [365 * 24 * 60 * 60]);
      await ethers.provider.send("evm_mine");
      
      // Should allow new mint
      await expect(
        contract.connect(user1).mint(...)
      ).to.not.be.reverted;
    });
    
    it("Should return correct eligibility status", async function () {
      const fid = 12345;
      
      expect(await contract.hasMintedThisYear(fid)).to.equal(false);
      
      await contract.connect(user1).mint(...);
      
      expect(await contract.hasMintedThisYear(fid)).to.equal(true);
    });
  });
  
  describe("Gas Optimization", function () {
    it("Should mint within gas target (150k)", async function () {
      const tx = await contract.connect(user1).mint(...);
      const receipt = await tx.wait();
      
      console.log("Gas used:", receipt.gasUsed.toString());
      expect(receipt.gasUsed).to.be.lessThan(160000);
    });
    
    it("Should pack data efficiently (2 storage slots)", async function () {
      await contract.connect(user1).mint(...);
      
      // Check storage layout
      const slot1 = await ethers.provider.getStorage(
        await contract.getAddress(),
        ethers.keccak256(ethers.toBeHex(1, 32))
      );
      
      expect(slot1).to.not.equal("0x" + "00".repeat(32));
    });
  });
});
```

Run tests:
```bash
npx hardhat test
npx hardhat coverage
```

Expected output:
```
  FarcasterYearlyCard
    Deployment
      âœ“ Should set the correct stats oracle
      âœ“ Should set correct mint fee
      âœ“ Should set correct royalty BPS
    Minting
      âœ“ Should mint a card with valid signature (150ms)
      âœ“ Should reject mint with invalid fee
      âœ“ Should reject double mint in same year
      âœ“ Should reject mint with invalid signature
    Rarity Calculation
      âœ“ Should calculate Legendary tier correctly
      âœ“ Should calculate Common tier correctly
    Royalty System
      âœ“ Should return correct royalty info
      âœ“ Should maintain minter as royalty receiver after transfer
    TokenURI
      âœ“ Should generate valid metadata JSON (200ms)
      âœ“ Should include all stats in attributes
    Eligibility
      âœ“ Should allow mint after year change
      âœ“ Should return correct eligibility status
    Gas Optimization
      âœ“ Should mint within gas target (150k)
      âœ“ Should pack data efficiently (2 storage slots)

  16 passing (2s)
```

INTEGRATION TESTS (Backend API):

```javascript
// backend/tests/api.test.js

const request = require('supertest');
const app = require('../index');
const redis = require('../services/redis');

describe('API Integration Tests', () => {
  beforeAll(async () => {
    // Setup test environment
    await redis.flushdb();
  });
  
  afterAll(async () => {
    await redis.quit();
  });
  
  describe('GET /api/stats/:fid', () => {
    it('should return stats for valid FID', async () => {
      const response = await request(app)
        .get('/api/stats/3')
        .expect(200);
      
      expect(response.body).toHaveProperty('fid', 3);
      expect(response.body).toHaveProperty('stats');
      expect(response.body).toHaveProperty('signature');
      expect(response.body).toHaveProperty('rarityScore');
      expect(response.body).toHaveProperty('canMint');
    });
    
    it('should return 400 for already minted FID', async () => {
      // Mock contract call
      jest.spyOn(contract, 'hasMintedThisYear').mockResolvedValue(true);
      
      const response = await request(app)
        .get('/api/stats/12345')
        .expect(400);
      
      expect(response.body).toHaveProperty('error');
      expect(response.body.error).toContain('Already minted');
    });
    
    it('should cache stats for 1 hour', async () => {
      await request(app).get('/api/stats/3');
      
      const cached = await redis.get('stats:3');
      expect(cached).not.toBeNull();
      
      const ttl = await redis.ttl('stats:3');
      expect(ttl).toBeGreaterThan(3500); // ~1 hour
    });
    
    it('should rate limit requests', async () => {
      // Make 11 requests (limit is 10/hour)
      for (let i = 0; i < 11; i++) {
        const response = await request(app).get('/api/stats/3');
        
        if (i < 10) {
          expect(response.status).toBe(200);
        } else {
          expect(response.status).toBe(429);
        }
      }
    });
  });
  
  describe('GET /api/leaderboard/:category', () => {
    it('should return top 100 for valid category', async () => {
      const response = await request(app)
        .get('/api/leaderboard/rarity')
        .expect(200);
      
      expect(response.body).toHaveProperty('leaderboard');
      expect(response.body.leaderboard).toHaveLength(100);
      expect(response.body.leaderboard[0]).toHaveProperty('rank', 1);
    });
    
    it('should return 400 for invalid category', async () => {
      await request(app)
        .get('/api/leaderboard/invalid')
        .expect(400);
    });
    
    it('should cache leaderboard for 1 hour', async () => {
      await request(app).get('/api/leaderboard/casts');
      
      const cached = await redis.get('api:leaderboard:casts:2025');
      expect(cached).not.toBeNull();
    });
  });
  
  describe('POST /api/verify', () => {
    it('should verify valid transaction hash', async () => {
      const response = await request(app)
        .post('/api/verify')
        .send({ txHash: '0x123...' })
        .expect(200);
      
      expect(response.body).toHaveProperty('verified', true);
    });
    
    it('should update leaderboard after verification', async () => {
      await request(app)
        .post('/api/verify')
        .send({ txHash: '0x123...' });
      
      // Check leaderboard updated
      const score = await redis.zscore('leaderboard:casts:2025', 'fid:3');
      expect(score).not.toBeNull();
    });
  });
});
```

Run integration tests:
```bash
npm test
```

END-TO-END TESTS (Playwright):

```javascript
// e2e/mint-flow.spec.js

const { test, expect } = require('@playwright/test');

test.describe('Mint Flow', () => {
  test('should complete full mint flow', async ({ page }) => {
    // Navigate to frame
    await page.goto('https://yearly.cards');
    
    // Wait for frame to load
    await page.waitForSelector('img[alt="Frame"]');
    
    // Click "Check Eligibility"
    await page.click('button:has-text("Check Eligibility")');
    
    // Should show stats preview
    await expect(page.locator('text=Your 2025 Stats')).toBeVisible();
    
    // Click "Mint Now"
    await page.click('button:has-text("Mint Now")');
    
    // Wallet popup should appear
    await page.waitForSelector('text=Confirm Transaction');
    
    // Mock wallet confirmation
    await page.evaluate(() => {
      window.ethereum.request = async () => ({
        hash: '0x123...'
      });
    });
    
    await page.click('button:has-text("Confirm")');
    
    // Should show success screen
    await expect(page.locator('text=Success!')).toBeVisible({ timeout: 30000 });
    
    // Should have share button
    await expect(page.locator('button:has-text("Share")')).toBeVisible();
  });
  
  test('should show error for already minted', async ({ page }) => {
    await page.goto('https://yearly.cards');
    
    // Mock API to return already minted
    await page.route('**/api/stats/*', route => {
      route.fulfill({
        status: 400,
        body: JSON.stringify({
          error: 'Already minted this year',
          nextEligible: 'January 1, 2026'
        })
      });
    });
    
    await page.click('button:has-text("Check Eligibility")');
    
    await expect(page.locator('text=Already minted')).toBeVisible();
    await expect(page.locator('text=January 1, 2026')).toBeVisible();
  });
  
  test('should navigate to leaderboard', async ({ page }) => {
    await page.goto('https://yearly.cards');
    await page.click('button:has-text("Leaderboard")');
    
    await expect(page.locator('text=Top 10')).toBeVisible();
    
    // Should show category buttons
    await expect(page.locator('button:has-text("Casts")')).toBeVisible();
    await expect(page.locator('button:has-text("Rarity")')).toBeVisible();
  });
});
```

Run E2E tests:
```bash
npx playwright test
```

SECURITY AUDIT CHECKLIST:

Smart Contract Security:
â˜ No reentrancy vulnerabilities
â˜ Integer overflow/underflow protected (Solidity 0.8+)
â˜ Access control properly implemented
â˜ Signature verification secure (uses ecrecover correctly)
â˜ No front-running risks
â˜ Gas limits reasonable
â˜ Emergency pause mechanism considered
â˜ Upgrade path defined (or explicitly non-upgradeable)

Backend Security:
â˜ Environment variables properly secured
â˜ API rate limiting implemented
â˜ Input validation on all endpoints
â˜ CORS configured correctly
â˜ SQL injection not possible (no SQL used)
â˜ Private keys stored securely
â˜ HTTPS enforced
â˜ Error messages don't leak sensitive info

Third-Party Audits:
- Optional: Hire audit firm ($5k-10k)
- Alternative: Bug bounty program ($500-2k rewards)
- Community review on GitHub

USER ACCEPTANCE TESTING:

Beta Testing Group (50-100 users):
1. Invite Farcaster power users
2. Provide testnet tokens
3. Walk through full flow
4. Collect feedback via form
5. Iterate based on feedback

Key Metrics to Track:
- Completion rate (% who finish mint)
- Drop-off points
- Time to complete flow
- Error frequency
- Gas costs (actual vs estimated)
- User satisfaction (1-5 scale)

LOAD TESTING:

```javascript
// load-test/stress.js

const { check } = require('k6');
const http = require('k6/http');

export const options = {
  stages: [
    { duration: '1m', target: 10 },   // Ramp up to 10 users
    { duration: '3m', target: 50 },   // Ramp up to 50 users
    { duration: '5m', target: 50 },   // Stay at 50 users
    { duration: '1m', target: 0 },    // Ramp down
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'], // 95% of requests < 500ms
    http_req_failed: ['rate<0.01'],   // <1% errors
  },
};

export default function () {
  const fid = Math.floor(Math.random() * 10000) + 1;
  
  const response = http.get(`https://api.yearly.cards/api/stats/${fid}`);
  
  check(response, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });
}
```

Run load test:
```bash
k6 run load-test/stress.js
```

Target Performance:
- 95th percentile response time: <500ms
- Error rate: <1%
- Throughput: 100 req/sec sustained
- Concurrent users: 50+

REGRESSION TESTING:

After each deployment:
1. Run full test suite
2. Verify on testnet
3. Test mint flow manually
4. Check OpenSea metadata
5. Verify leaderboard updates
6. Test royalty calculation
7. Smoke test all endpoints

Automated CI/CD Pipeline:
```yaml
# .github/workflows/test.yml

name: Test Suite

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run unit tests
        run: npx hardhat test
      
      - name: Run coverage
        run: npx hardhat coverage
      
      - name: Run integration tests
        run: npm test
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
```

MONITORING IN PRODUCTION:

Key Metrics to Track:
- Mint success rate
- Average gas cost
- API response times
- Error rates
- Signature verification failures
- Neynar API failures
- Redis cache hit rate

Alerting Thresholds:
- Error rate >5% â†’ immediate alert
- Response time >1s â†’ warning
- Gas cost >200k â†’ warning
- Contract balance low â†’ notification


================================================================================
1ï¸âƒ£6ï¸âƒ£ EDGE CASES & ERROR HANDLING
================================================================================

EDGE CASE CATALOG:

1. NEW USER (FID < 365 days old)
   â”œâ”€ Stats will be incomplete
   â”œâ”€ Consistency score lower (proportional to days active)
   â”œâ”€ Still eligible to mint
   â””â”€ Likely Common/Uncommon tier

   Handling:
   ```javascript
   // Calculate proportional consistency
   const accountAge = Date.now() - accountCreatedDate;
   const monthsActive = Math.min(12, Math.floor(accountAge / (30 * 24 * 60 * 60 * 1000)));
   const consistency = calculateConsistency(casts, monthsActive);
   ```

2. INACTIVE USER (0 casts in period)
   â”œâ”€ All stats = 0 or very low
   â”œâ”€ Rarity score: 0
   â”œâ”€ Result: Common tier
   â””â”€ Still can mint (historical proof)

   Handling:
   ```javascript
   if (stats.casts === 0) {
     return {
       ...stats,
       rarityScore: 0,
       rarityTier: 'common',
       message: 'Your card shows your Farcaster journey is just beginning!'
     };
   }
   ```

3. DELETED ACCOUNT
   â”œâ”€ Neynar API returns 404
   â”œâ”€ Cannot fetch current stats
   â”œâ”€ Cannot mint new card
   â””â”€ Existing NFTs remain valid

   Handling:
   ```javascript
   try {
     const user = await neynar.fetchUser(fid);
   } catch (error) {
     if (error.status === 404) {
       return {
         error: 'Account not found or deleted',
         canMint: false
       };
     }
     throw error;
   }
   ```

4. USERNAME CHANGE
   â”œâ”€ Card stores username at mint time
   â”œâ”€ Historical record preserved
   â”œâ”€ Future cards show new username
   â””â”€ Creates "vintage" collectible value

   Handling:
   ```solidity
   // Store username at mint time (immutable)
   _fullUsernames[tokenId] = username;
   
   // Display shows historical username
   function getUsername(uint256 tokenId) external view returns (string memory) {
       return _fullUsernames[tokenId]; // Never changes
   }
   ```

5. STATS OVERFLOW (>65,535)
   â”œâ”€ uint16 max = 65,535
   â”œâ”€ Very rare (top 0.01% users)
   â”œâ”€ Cap at max value
   â””â”€ Still Legendary tier

   Handling:
   ```javascript
   function sanitizeStats(stats) {
     const MAX_UINT16 = 65535;
     return {
       casts: Math.min(stats.casts, MAX_UINT16),
       likes: Math.min(stats.likes, MAX_UINT16),
       replies: Math.min(stats.replies, MAX_UINT16),
       recasts: Math.min(stats.recasts, MAX_UINT16),
       followers: Math.min(stats.followers, MAX_UINT16),
       consistency: Math.min(stats.consistency, 12),
       uniqueInteractors: Math.min(stats.uniqueInteractors, 4294967295) // uint32
     };
   }
   ```

6. YEAR BOUNDARY EDGE CASE
   â”œâ”€ Mint Dec 31, 11:59 PM â†’ allowed
   â”œâ”€ Mint Jan 1, 12:01 AM â†’ allowed (new year)
   â”œâ”€ Both valid, different tokens
   â””â”€ Creates "Twin Cards" collectible

   Handling:
   ```solidity
   function hasMintedThisYear(uint32 fid) public view returns (bool) {
       uint16 currentYear = uint16(block.timestamp / 365 days + 1970);
       return _lastMintYear[fid] == currentYear;
   }
   
   // User can mint every January 1st regardless of last mint date
   ```

7. SIGNATURE EXPIRY
   â”œâ”€ Signature valid for 10 minutes
   â”œâ”€ Prevents replay attacks
   â”œâ”€ User must re-fetch if expired
   â””â”€ Clear error message

   Handling:
   ```javascript
   const SIGNATURE_TTL = 10 * 60 * 1000; // 10 minutes
   
   function isSignatureExpired(signature) {
     return Date.now() > signature.expiresAt;
   }
   
   // Frontend check before submit
   if (isSignatureExpired(signature)) {
     alert('Stats signature expired. Refreshing...');
     const newStats = await fetchStats(fid);
     // Use new signature
   }
   ```

8. NETWORK CONGESTION (HIGH GAS)
   â”œâ”€ Gas cost may exceed $5-10
   â”œâ”€ Warn user before transaction
   â”œâ”€ Option to wait for lower gas
   â””â”€ Transaction will still succeed

   Handling:
   ```javascript
   const gasPrice = await provider.getFeeData();
   const estimatedGas = 150000;
   const gasCost = gasPrice.maxFeePerGas * estimatedGas;
   const gasCostUSD = ethToUSD(ethers.formatEther(gasCost));
   
   if (gasCostUSD > 2) {
     showWarning(`Gas cost is high ($${gasCostUSD}). Consider waiting for lower fees.`);
   }
   ```

9. NEYNAR API DOWN
   â”œâ”€ Cannot fetch stats
   â”œâ”€ Mint flow blocked
   â”œâ”€ Cached data used if available
   â””â”€ Retry with exponential backoff

   Handling:
   ```javascript
   async function fetchWithRetry(url, retries = 3) {
     for (let i = 0; i < retries; i++) {
       try {
         const response = await fetch(url);
         if (response.ok) return response.json();
       } catch (error) {
         if (i === retries - 1) throw error;
         await sleep(2 ** i * 1000); // Exponential backoff
       }
     }
   }
   
   // Fallback to cached data
   if (error) {
     const cached = await redis.get(`stats:${fid}`);
     if (cached) {
       return JSON.parse(cached);
     }
     throw new Error('Unable to fetch stats. Please try again later.');
   }
   ```

10. MULTIPLE WALLETS, SAME FID
    â”œâ”€ User can mint from any wallet they control
    â”œâ”€ Eligibility tied to FID, not wallet
    â”œâ”€ Royalties go to minting wallet
    â””â”€ Each mint = different wallet = different royalty receiver

    Handling:
    ```solidity
    // Store minter wallet address
    _cards[tokenId].minter = msg.sender;
    
    // Royalties always go to original minting wallet
    function royaltyInfo(uint256 tokenId, uint256 salePrice)
        external view returns (address, uint256)
    {
        return (_cards[tokenId].minter, salePrice * 300 / 10000);
    }
    ```

ERROR HANDLING PATTERNS:

Backend API Errors:
```javascript
// Centralized error handler
app.use((error, req, res, next) => {
  console.error('Error:', error);
  
  // Neynar API errors
  if (error.code === 'NEYNAR_API_ERROR') {
    return res.status(503).json({
      error: 'Stats service temporarily unavailable',
      retryAfter: 60
    });
  }
  
  // Redis errors
  if (error.code === 'REDIS_CONNECTION_ERROR') {
    // Degrade gracefully (no caching, but still functional)
    return res.status(200).json({
      ...data,
      cached: false
    });
  }
  
  // Contract errors
  if (error.code === 'CALL_EXCEPTION') {
    return res.status(400).json({
      error: 'Blockchain query failed',
      details: error.message
    });
  }
  
  // Default error
  res.status(500).json({
    error: 'Internal server error',
    requestId: req.id
  });
});
```

Smart Contract Errors:
```solidity
// Custom errors (gas-efficient)
error InvalidFee();
error AlreadyMinted();
error InvalidSignature();
error InvalidConsistency();
error TokenDoesNotExist();

function mint(...) external payable {
    if (msg.value != MINT_FEE) revert InvalidFee();
    if (hasMintedThisYear(fid)) revert AlreadyMinted();
    if (consistency > 12) revert InvalidConsistency();
    if (!_verifySignature(hash, signature)) revert InvalidSignature();
    
    // ... mint logic
}
```

Frontend Error Display:
```typescript
// User-friendly error messages
const ERROR_MESSAGES = {
  'InvalidFee': 'Please send exactly 0.0005 ETH',
  'AlreadyMinted': 'You\'ve already minted a card this year. Come back January 1!',
  'InvalidSignature': 'Stats verification failed. Please refresh and try again.',
  'InsufficientFunds': 'You don\'t have enough ETH. You need ~0.001 ETH for mint + gas.',
  'UserRejected': 'Transaction cancelled. No charges were made.',
  'NetworkError': 'Network connection issue. Please check your internet and try again.',
  'RateLimited': 'Too many requests. Please wait a minute and try again.'
};

function displayError(error) {
  const message = ERROR_MESSAGES[error.code] || 'Something went wrong. Please try again.';
  showToast(message, 'error');
}
```

GRACEFUL DEGRADATION:

Scenario: Redis Down
```javascript
// Cache miss â†’ fetch from source
async function getLeaderboard(category) {
  try {
    const cached = await redis.get(`leaderboard:${category}`);
    if (cached) return JSON.parse(cached);
  } catch (error) {
    console.warn('Redis unavailable, fetching from source');
  }
  
  // Fallback: fetch directly from contract
  const events = await contract.queryFilter('CardMinted');
  return calculateLeaderboard(events);
}
```

Scenario: Neynar API Rate Limited
```javascript
// Use cached data with warning
if (error.status === 429) {
  const cached = await redis.get(`stats:${fid}`);
  if (cached) {
    return {
      ...JSON.parse(cached),
      warning: 'Showing cached data (may be up to 1 hour old)'
    };
  }
}
```

Scenario: Contract Call Fails
```javascript
// Retry with different RPC
const RPC_ENDPOINTS = [
  'https://mainnet.base.org',
  'https://base.gateway.tenderly.co',
  'https://base-mainnet.public.blastapi.io'
];

async function callContractWithFallback(method, ...args) {
  for (const rpc of RPC_ENDPOINTS) {
    try {
      const provider = new ethers.JsonRpcProvider(rpc);
      const contract = new ethers.Contract(ADDRESS, ABI, provider);
      return await contract[method](...args);
    } catch (error) {
      console.warn(`RPC ${rpc} failed, trying next...`);
      continue;
    }
  }
  throw new Error('All RPC endpoints failed');
}
```


================================================================================
1ï¸âƒ£7ï¸âƒ£ ROADMAP & FUTURE FEATURES
================================================================================

PHASE 1: LAUNCH (Month 1-3) âœ… Current Blueprint

Core Features:
âœ… Smart contract deployment
âœ… Basic minting (1 per year)
âœ… 7 stats tracking
âœ… Rarity system (5 tiers)
âœ… On-chain SVG
âœ… ERC2981 royalties
âœ… Farcaster Frame
âœ… Leaderboard (7 categories)

PHASE 2: ENHANCEMENTS (Month 4-6)

New Features:
ğŸ”² Achievement Badges
   â”œâ”€ "Perfect Year" (12/12 consistency)
   â”œâ”€ "Social Butterfly" (500+ unique interactors)
   â”œâ”€ "Early Adopter" (FID < 10,000)
   â””â”€ "Content King" (2,000+ casts)

ğŸ”² Advanced Analytics Dashboard
   â”œâ”€ Historical stats comparison
   â”œâ”€ Growth trends
   â”œâ”€ Peer benchmarking
   â””â”€ Predictive rarity for next year

ğŸ”² Card Showcase Gallery
   â”œâ”€ Public profile pages
   â”œâ”€ Filter by rarity/year
   â”œâ”€ Social sharing optimized
   â””â”€ Embed widgets

ğŸ”² Referral System
   â”œâ”€ Unique referral codes
   â”œâ”€ 10% discount for referee
   â”œâ”€ Bonus stats for referrer
   â””â”€ Leaderboard for top referrers

PHASE 3: SOCIAL FEATURES (Month 7-9)

New Features:
ğŸ”² Card Trading Platform
   â”œâ”€ Built-in marketplace
   â”œâ”€ Offer/bid system
   â”œâ”€ Trade history
   â””â”€ Price charts

ğŸ”² Card Comparisons
   â”œâ”€ Side-by-side stats
   â”œâ”€ "Battle" mode (higher stats wins)
   â”œâ”€ Share comparison image
   â””â”€ Tournament brackets

ğŸ”² Collaborative Cards
   â”œâ”€ Team/DAO cards
   â”œâ”€ Combined stats
   â”œâ”€ Shared royalties
   â””â”€ Multi-sig minting

ğŸ”² Card Staking
   â”œâ”€ Stake card to earn rewards
   â”œâ”€ Longer stake = higher rewards
   â”œâ”€ Unlock special features
   â””â”€ Governance participation

PHASE 4: EXPANSION (Month 10-12)

New Features:
ğŸ”² Multi-Chain Deployment
   â”œâ”€ Optimism
   â”œâ”€ Arbitrum
   â”œâ”€ Polygon
   â””â”€ Unified collection

ğŸ”² Historical Archives
   â”œâ”€ Mint past year cards (if eligible)
   â”œâ”€ Retroactive stats calculation
   â”œâ”€ "Time Machine" feature
   â””â”€ Complete collection incentive

ğŸ”² Special Editions
   â”œâ”€ Event cards (Farcon, etc.)
   â”œâ”€ Collaboration cards (with protocols)
   â”œâ”€ Limited editions (100 mints)
   â””â”€ Premium pricing ($5-50)

ğŸ”² Mobile App
   â”œâ”€ Native iOS/Android
   â”œâ”€ Push notifications
   â”œâ”€ Wallet integration
   â””â”€ Offline viewing

PHASE 5: ECOSYSTEM (Year 2)

New Features:
ğŸ”² Developer API
   â”œâ”€ Public API for stats
   â”œâ”€ Embeddable widgets
   â”œâ”€ Webhooks for events
   â””â”€ Rate limits + pricing tiers

ğŸ”² Reputation System
   â”œâ”€ Cards as proof of reputation
   â”œâ”€ Integration with other protocols
   â”œâ”€ Verifiable credentials
   â””â”€ Cross-platform identity

ğŸ”² Gamification Layer
   â”œâ”€ Quests & challenges
   â”œâ”€ Seasonal events
   â”œâ”€ Rewards for engagement
   â””â”€ Leaderboard prizes

ğŸ”² DAO Governance
   â”œâ”€ Card holders vote on features
   â”œâ”€ Treasury management
   â”œâ”€ Parameter adjustments
   â””â”€ Community grants

TECHNICAL IMPROVEMENTS (Ongoing):

Performance:
â”œâ”€ Gas optimization (target <100k per mint)
â”œâ”€ Faster API response times (<200ms)
â”œâ”€ CDN for static assets
â””â”€ Database query optimization

Security:
â”œâ”€ Third-party audit (Year 1)
â”œâ”€ Bug bounty program
â”œâ”€ Regular security reviews
â””â”€ Incident response plan

Scalability:
â”œâ”€ Load balancing
â”œâ”€ Horizontal scaling
â”œâ”€ Database sharding
â””â”€ Rate limit increases

Developer Experience:
â”œâ”€ Open source core libraries
â”œâ”€ Comprehensive documentation
â”œâ”€ Code examples & tutorials
â””â”€ Community Discord

METRICS FOR SUCCESS:

Year 1 Targets:
â”œâ”€ 10,000 total mints
â”œâ”€ 5,000 unique minters
â”œâ”€ $15,000 protocol revenue
â”œâ”€ $50,000 secondary trading volume
â”œâ”€ 60% retention (mint again in Year 2)
â””â”€ 4.5/5 average user rating

Year 2 Targets:
â”œâ”€ 50,000 total mints
â”œâ”€ 25,000 unique minters
â”œâ”€ $75,000 protocol revenue
â”œâ”€ $500,000 secondary trading volume
â”œâ”€ 70% retention (mint again in Year 3)
â”œâ”€ 10,000+ Discord members
â”œâ”€ Integration with 5+ other protocols
â””â”€ Featured in 3+ major crypto publications

Year 3 Targets:
â”œâ”€ 200,000 total mints
â”œâ”€ 100,000 unique minters
â”œâ”€ $300,000 protocol revenue
â”œâ”€ $2M+ secondary trading volume
â”œâ”€ 75% retention
â”œâ”€ 50,000+ community members
â”œâ”€ Multi-chain presence (5+ chains)
â””â”€ Industry-standard reputation primitive

COMMUNITY INITIATIVES:

Ongoing Programs:
ğŸ”² Weekly Twitter Spaces
   â””â”€ Feature top cards, discuss roadmap

ğŸ”² Monthly Card Contests
   â”œâ”€ Best improvement month-over-month
   â”œâ”€ Most creative card display
   â””â”€ Prizes: Free mints, ETH, special editions

ğŸ”² Ambassador Program
   â”œâ”€ 10 ambassadors globally
   â”œâ”€ Compensation: $500/month + bonus
   â””â”€ Responsibilities: Community support, content

ğŸ”² Educational Content
   â”œâ”€ How-to guides
   â”œâ”€ Video tutorials
   â”œâ”€ Case studies
   â””â”€ Best practices

PARTNERSHIP OPPORTUNITIES:

Target Partners:
â”œâ”€ Farcaster Clients (Warpcast, Supercast)
â”œâ”€ NFT Marketplaces (Zora, Manifold)
â”œâ”€ Analytics Platforms (Dune, Nansen)
â”œâ”€ Wallet Providers (Rainbow, Coinbase Wallet)
â”œâ”€ Social Protocols (Lens, Orb)
â””â”€ DAOs & Communities

Partnership Models:
â”œâ”€ Co-marketing campaigns
â”œâ”€ Integration APIs
â”œâ”€ Revenue sharing
â”œâ”€ Custom card editions
â””â”€ Cross-promotion

EXPERIMENTAL FEATURES (R&D):

Exploring:
ğŸ”¬ AI-Generated Card Art
   â”œâ”€ Personalized designs based on stats
   â”œâ”€ Style transfer based on user preferences
   â””â”€ Dynamic evolution over time

ğŸ”¬ On-Chain Activity Tracking
   â”œâ”€ Beyond Farcaster: Twitter, GitHub, etc.
   â”œâ”€ Web3 activity (DeFi, NFTs, governance)
   â””â”€ Unified reputation score

ğŸ”¬ Predictive Analytics
   â”œâ”€ ML models for rarity prediction
   â”œâ”€ Growth trajectory forecasting
   â””â”€ Personalized recommendations

ğŸ”¬ AR/VR Integration
   â”œâ”€ View cards in augmented reality
   â”œâ”€ Virtual card galleries
   â””â”€ Metaverse displays

ğŸ”¬ Physical Cards
   â”œâ”€ Print-on-demand service
   â”œâ”€ QR codes linking to NFT
   â”œâ”€ NFC chips for verification
   â””â”€ Limited edition physicals

LONG-TERM VISION (5+ Years):

The Future:
ğŸš€ Universal Social Reputation Layer
   â”œâ”€ Cards recognized across all platforms
   â”œâ”€ Portable reputation primitive
   â”œâ”€ Integration with 100+ apps
   â””â”€ Standard for on-chain identity

ğŸš€ Decentralized Governance
   â”œâ”€ Full community ownership
   â”œâ”€ Protocol-owned liquidity
   â”œâ”€ Sustainable token economics
   â””â”€ Grant programs for ecosystem

ğŸš€ Cross-Platform Standard
   â”œâ”€ API adopted by major social platforms
   â”œâ”€ Open protocol specifications
   â”œâ”€ Reference implementations
   â””â”€ Academic research citations

SUCCESS CRITERIA:

We'll know we've succeeded when:
âœ… Cards are regularly referenced in crypto Twitter conversations
âœ… "What's your rarity tier?" becomes a common question
âœ… Other projects build on top of our infrastructure
âœ… Users mint cards purely for the historical record
âœ… Secondary market thrives with organic demand
âœ… Community self-organizes and creates value
âœ… Protocol is financially sustainable without external funding
âœ… The product is so simple, your grandma could mint a card


================================================================================
                            APPENDIX & RESOURCES
================================================================================

USEFUL LINKS:

Documentation:
â”œâ”€ Solidity Docs: https://docs.soliditylang.org
â”œâ”€ Hardhat: https://hardhat.org/docs
â”œâ”€ Ethers.js: https://docs.ethers.org
â”œâ”€ Frog Framework: https://frog.fm
â”œâ”€ Neynar API: https://docs.neynar.com
â”œâ”€ Base Chain: https://docs.base.org
â””â”€ OpenSea Metadata: https://docs.opensea.io/docs/metadata-standards

Tools:
â”œâ”€ RemixIDE: https://remix.ethereum.org
â”œâ”€ Tenderly: https://tenderly.co (debugging)
â”œâ”€ BaseScan: https://basescan.org
â”œâ”€ OpenSea Testnet: https://testnets.opensea.io
â”œâ”€ Warpcast Frame Validator: https://warpcast.com/~/developers/frames
â””â”€ Upstash: https://upstash.com

Community:
â”œâ”€ Farcaster: warpcast.com/~/channel/dev
â”œâ”€ Base Discord: discord.gg/base
â”œâ”€ Paradigm (Frog): t.me/wevm
â””â”€ GitHub Repo: github.com/anotherbobby/yearlysocialcard

SMART CONTRACT ADDRESSES:

Production (Base Mainnet):
â”œâ”€ Contract: [TO BE DEPLOYED]
â”œâ”€ Chain ID: 8453
â””â”€ Block Explorer: https://basescan.org

Testnet (Base Goerli):
â”œâ”€ Contract: [TEST DEPLOYMENT]
â”œâ”€ Chain ID: 84531
â””â”€ Block Explorer: https://goerli.basescan.org

KEY ENVIRONMENT VARIABLES:
```bash
# Smart Contract
CONTRACT_ADDRESS=0x...
DEPLOYER_PRIVATE_KEY=0x...
STATS_ORACLE_PRIVATE_KEY=0x...
BASESCAN_API_KEY=...

# Backend API
API_URL=https://api.yearly.cards
NEYNAR_API_KEY=...
REDIS_URL=redis://...
PORT=3000

# Frame
NEXT_PUBLIC_FRAME_URL=https://yearly.cards
NEXT_PUBLIC_CONTRACT_ADDRESS=0x...
NEXT_PUBLIC_CHAIN_ID=8453

# External Services
DISCORD_WEBHOOK=https://discord.com/api/webhooks/...
SENTRY_DSN=https://...@sentry.io/...
UPTIME_ROBOT_API_KEY=...
```

GAS OPTIMIZATION SUMMARY:

Total Savings Achieved:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Optimization                â”‚ Gas Saved  â”‚ Cost Saved         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Data packing (2 slots)      â”‚  ~160,000  â”‚ $1.20 per mint     â”‚
â”‚ On-demand SVG               â”‚   ~30,000  â”‚ $0.22 per mint     â”‚
â”‚ Simple eligibility check    â”‚   ~18,000  â”‚ $0.14 per mint     â”‚
â”‚ Solady ERC721               â”‚   ~15,000  â”‚ $0.11 per mint     â”‚
â”‚ Minimal events              â”‚    ~6,000  â”‚ $0.04 per mint     â”‚
â”‚ Immutable variables         â”‚    ~2,000  â”‚ $0.02 per mint     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ TOTAL                       â”‚  ~231,000  â”‚ $1.73 per mint     â”‚
â”‚                                                                 â”‚
â”‚ Before optimization: ~450k gas (~$3.30)                        â”‚
â”‚ After optimization:  ~150k gas (~$0.60)                        â”‚
â”‚ Savings: 67% reduction in gas costs                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

FINANCIAL PROJECTIONS SUMMARY:

Conservative (Year 1):
â”œâ”€ Mints: 2,430
â”œâ”€ Revenue: $3,645
â”œâ”€ Costs: $1,080
â”œâ”€ Net Profit: $2,565
â””â”€ Break-even: Month 2

Moderate (Year 1):
â”œâ”€ Mints: 5,000
â”œâ”€ Revenue: $7,500
â”œâ”€ Costs: $1,080
â”œâ”€ Net Profit: $6,420
â””â”€ Break-even: Month 1

Optimistic (Year 1):
â”œâ”€ Mints: 10,000
â”œâ”€ Revenue: $15,000
â”œâ”€ Costs: $1,080
â”œâ”€ Net Profit: $13,920
â””â”€ Break-even: Month 1

TECH STACK SUMMARY:

Frontend:
â”œâ”€ Framework: Frog (Hono + React)
â”œâ”€ Hosting: Vercel
â”œâ”€ Domain: Cloudflare/Vercel DNS
â””â”€ Cost: $0-20/month

Backend:
â”œâ”€ Runtime: Node.js 18+
â”œâ”€ Framework: Express
â”œâ”€ Hosting: Railway/Render
â”œâ”€ Database: Redis (Upstash)
â””â”€ Cost: $20-50/month

Blockchain:
â”œâ”€ Chain: Base L2 (Ethereum)
â”œâ”€ Language: Solidity 0.8.20
â”œâ”€ Framework: Hardhat
â”œâ”€ Library: Solady (optimized ERC721)
â””â”€ Cost: ~$30 one-time deployment

External APIs:
â”œâ”€ Neynar: Farcaster data ($50/month)
â”œâ”€ Base RPC: Free (public endpoints)
â””â”€ OpenSea API: Free

Total Monthly: ~$90

DEPLOYMENT TIMELINE:

Week 1: Development
â”œâ”€ Day 1-2: Smart contract development
â”œâ”€ Day 3-4: Backend API development
â”œâ”€ Day 5-6: Frame development
â””â”€ Day 7: Integration testing

Week 2: Testing
â”œâ”€ Day 1-2: Unit tests
â”œâ”€ Day 3-4: Integration tests
â”œâ”€ Day 5-6: Testnet deployment
â””â”€ Day 7: E2E testing

Week 3: Pre-Launch
â”œâ”€ Day 1-2: Mainnet deployment
â”œâ”€ Day 3-4: Security review
â”œâ”€ Day 5-6: Beta testing (50 users)
â””â”€ Day 7: Documentation & marketing prep

Week 4: Launch
â”œâ”€ Day 1: Public launch
â”œâ”€ Day 2-7: Monitor & iterate
â””â”€ Ongoing: Community engagement

CONTACT & SUPPORT:

For Questions:
â”œâ”€ GitHub Issues: github.com/anotherbobby/yearlysocialcard/issues
â”œâ”€ Farcaster: @anotherbobby
â”œâ”€ Email: hello@yearly.cards
â””â”€ Discord: [TO BE CREATED]

Contributing:
â”œâ”€ Code: Pull requests welcome
â”œâ”€ Bug Reports: GitHub Issues
â”œâ”€ Feature Requests: GitHub Discussions
â””â”€ Documentation: PRs to /docs folder

License: MIT


================================================================================
                              END OF BLUEPRINT
================================================================================

Version: 2.0 - Complete Production-Ready Specification
Last Updated: November 22, 2025
Status: Ready for Implementation

Total Deployment Cost: ~$100 (contract + initial setup)
Monthly Operating Cost: ~$90
Break-Even: 60 mints/month (~2 per day)
Target Year 1 Revenue: $7,500-$15,000

Key Success Metrics:
âœ… Gas cost: <$0.80 per mint
âœ… Response time: <500ms API
âœ… Uptime: >99.9%
âœ… User satisfaction: >4.5/5
âœ… Retention: >60% year-over-year

This blueprint provides everything needed to build, deploy, and scale
a sustainable NFT project on Base that genuinely serves the Farcaster
community while maintaining economic viability.

Good luck! ğŸš€

Questions or feedback: github.com/anotherbobby/yearlysocialcard

================================================================================
